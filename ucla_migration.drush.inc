    <?php

    /**
     * @file
     * A drush script for UCLA collection migration.
     */

    /**
     * Implements hook_drush_command().
     */
    function ucla_migration_drush_command() {
        $items = array();
        $items['ucla_save_pids_for_namespace'] = array(
            'callback' => 'ucla_migration_save_pids_for_namespace',
            'description' => 'Gets all PIDS for the given namespace and saves them to a file.',
            'arguments' => array(
                'fedora_namespace' => "The Fedora namespace whose PIDS you're looking for.",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_save_pids_for_namespace your_namespace',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_delete_fedoraObject_by_nameSpace'] = array(
            'callback' => 'delete_fedoraObject_by_nameSpace',
            'description' => 'delete all the objects in a given namespace',
            'arguments' => array(
                'fedora_namespace' => "The Fedora namespace whose PIDS you're looking for.",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_delete_fedoraObject_by_nameSpace fedora_namespace',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_delete_fedoraObject_by_pids'] = array(
            'callback' => 'delete_fedoraObject_by_pids',
            'description' => 'delete all the objects in a given namespace',
            'arguments' => array(
                'pids' => " PIDS to delete",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_delete_fedoraObject_by_pids pidsfilepath',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_delete_fedoraObject_by_nameSpace_searchQuery'] = array(
            'callback' => 'delete_fedoraObject_by_nameSpace_searchQuery',
            'description' => 'delete all the objects in a given namespace and search query',
            'arguments' => array(
                'fedora_namespace' => "The Fedora namespace whose PIDS you're looking for.",
                'label_search' => "label name to be searched",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_delete_fedoraObject_by_nameSpace_searchQuery fedora_namespace label_search',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_fix_fedoraObject_relsExt_by_pids'] = array(
            'callback' => 'fix_fedoraObject_relsExt_by_pids',
            'description' => 'fix all the objects in a given pids to add mansucript content model',
            'arguments' => array(
                'pids' => "The PIDS you're looking for.",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com fix_fedoraObject_relsExt_by_nameSpace pids',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_fix_fedoraObject_metadata_by_pids'] = array(
            'callback' => 'fix_fedoraObject_metadata_by_pids',
            'description' => 'fix all the objects in a given pids to add genre',
            'arguments' => array(
                'pids' => "The PIDS you're looking for.",
                'metadata_value' => "Value of genre that needs to be added to mods",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_fix_fedoraObject_metadata_by_pids pids metadata_value',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_update_metadata_for_mods_by_pids'] = array(
            'callback' => 'update_metadata_for_mods_by_pids',
            'description' => 'fix all the objects in a given pids to update mods element value',
            'arguments' => array(
                'pids' => "The PIDS you're looking for.",
                'old_metadata_value' => "Old Value of metadata that needs to be replaced",
                'new_metadata_value' => "New Value of metadata to update with",
                'local_name' => "mods element to update",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 ucla_update_metadata_for_mods_by_pids pids old_metadata_value new_metadata_value local_name',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_add_program_idep_to_metadata_by_namespace'] = array(
            'callback' => 'add_program_idep_to_metadata_by_namespace',
            'description' => 'fix all the objects in a given pids to update mods element value',
            'arguments' => array(
                'fedora_namespace' => "The Fedora namespace whose PIDS you're looking for.",

            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 ucla_add_program_idep_to_metadata_by_namespace fedora_namespace',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_add_program_idep_to_metadata_by_pids'] = array(
            'callback' => 'add_program_idep_to_metadata_by_pids',
            'description' => 'fix all the objects in a given pids to update mods element value',
            'arguments' => array(
                'pids' => "The PIDS you're looking for.",

            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 ucla_add_program_idep_to_metadata_by_pids pids_file',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_delete_mods_element_by_pids'] = array(
            'callback' => 'delete_mods_element_by_pids',
            'description' => 'delete mods element by local_name for the  given pids',
            'arguments' => array(
                'pids' => "The PIDS you're looking for.",
                'local_name' => "mods element local name(without the namespace)",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 ucla_delete_mods_element_by_pids pids local_name',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_update_Label_from_DC_for_namespace'] = array(
            'callback' => 'update_Label_from_DC_for_namespace',
            'description' => 'convert dc from mods, if add_mods flag is set to true , ingest the MODS datastream along with DC datastream',
            'arguments' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_update_Label_from_DC_for_namespace fedora_namespace',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_update_Label_from_DC_for_PIDS'] = array(
            'callback' => 'update_Label_from_DC_for_PIDS',
            'description' => 'update fedora label to the one from dc:title ',
            'arguments' => array(
                'pids' => array(
                    'description' => 'list of PIDS for which the labels need to be updated',
                    'required' => 'true'
                ),
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 ucla_update_Label_from_DC_for_PIDS pids',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_update_DC_from_MODS_for_namespace'] = array(
            'callback' => 'update_DC_from_MODS_for_namespace',
            'description' => 'convert dc from mods, if add_mods flag is set to true , ingest the MODS datastream along with DC datastream',
            'arguments' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1  ucla_update_DC_from_MODS_for_namespace fedora_namespace',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_update_DC_from_MODS_for_PIDS'] = array(
            'callback' => 'update_DC_from_MODS_for_PIDS',
            'description' => 'convert dc from mods, if add_mods flag is set to true , ingest the MODS datastream along with DC datastream',
            'arguments' => array(
                'pids' => array(
                    'description' => 'list of PIDS for which Mods metadata will be added to DC fields',
                    'required' => 'true'
                ),
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1  ucla_update_DC_from_MODS_for_PIDS pids',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_add_genre_to_MODS_for_namespace'] = array(
            'callback' => 'add_genre_to_MODS_for_namespace',
            'description' => 'add missing genre to dep mods',
            'arguments' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 ucla_add_genre_to_MODS_for_namespace --fedora_namespace=greenmovement',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_make_namespace_versionable'] = array(
            'callback' => 'ucla_migration_make_all_datastreams_versionable',
            'description' => "Sets all datastreams for all objects to versionable in the given namespace. Only run after executing ucla_save_pids_for_namespace and confirming that Fedora's resource index is turned off.",
            'arguments' => array(
                'fedora_namespace' => "The Fedora namespace whose objects' datastreams you wish to make versionable.",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_make_namespace_versionable your_namespace',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );
        $items['ucla_migrate_mets'] = array(
            'callback' => 'ucla_migration_migrate_mets',
            'description' => 'Ingest content from METS file for all records.',
            'arguments' => array(
                'file_path' => 'The file path to the METS file.',
                'fedora_namespace' => "The Fedora namespace to ingest everything under.",
                'recovery_number' => "The numerical portion of the PID of the last ingested object.",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_migrate_mets /home/dgiuser/21198-zz00294nxr.xml uclans',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );
        $items['ucla_migrate_from_dmdid'] = array(
            'callback' => 'ucla_migration_migrate_from_dmdid',
            'description' => 'Ingest content from METS file for a single record.',
            'arguments' => array(
                'file_path' => 'The file path to the METS file.',
                'fedora_namespace' => "The Fedora namespace to ingest the record under.",
                'dmdid' => "The record ID provided in the MODS for this particular record.",
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_migrate_from_dmdid /home/dgiuser/21198-zz00294nxr.xml uclans 21198-zz002bzvvs',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );
        $items['ucla_migrate_datastream'] = array(
            'callback' => 'ucla_migration_migrate_datastream',
            'description' => 'Ingest content from METS file to update datastreams to objects that already exist in Fedora.',
            'arguments' => array(
                'file_path' => 'The file path to the METS file.',
                'datastream_path' => 'The file path to the directory containing the datastreams (can be remote or local)',
                'fedora_namespace' => 'The Fedora namespace to update the datastreams under.',
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_migrate_datastream http://example.com/datastream_dir edu.ucla.library.tahrir',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );
        $items['ucla_migrate_attach_datastream'] = array(
            'callback' => 'ucla_migration_attach_datastream',
            'description' => 'Ingest content from METS file to update datastreams to objects that already exist in Fedora.',
            'arguments' => array(
                'datastream_path' => 'The file path to the file containing paths to the assets.',
                'datastream_id' => 'The datastream id to assign to the added asset, will also be used for the ds label',
                'mime_type' => 'The mime type to add to the attached datastream',
                'fedora_namespace' => 'The Fedora namespace to update the datastreams under.',
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_migrate_attach_datastream http://example.com/datastream_file_of_assets PDF_FILE application/pdf edu.ucla.library.project ',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_migrate_attach_datastream'] = array(
            'callback' => 'ucla_migration_attach_datastream',
            'description' => 'Ingest content from a specified source to update datastreams to objects that already exist in Fedora.',
            'arguments' => array(
                'datastream_path' => 'The file path to the file containing paths to the assets.',
                'datastream_id' => 'The datastream id to assign to the added asset, will also be used for the ds label',
                'mime_type' => 'The mime type to add to the attached datastream',
                'fedora_namespace' => 'The Fedora namespace to update the datastreams under.',
            ),
            'options' => array(),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_migrate_attach_datastream http://example.com/datastream_file_of_assets PDF_FILE application/pdf edu.ucla.library.project ',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_migrate_delete_datastream'] = array(
            'callback' => 'ucla_migration_delete_datastream',
            'description' => 'Delete a datastream given a datastream id and options for deletion.',
            'options' => array(
                'datastream_id' => array(
                    'description' => 'The datastream id to assign to the added asset, will also be used for the ds label',
                    'required' => 'true'
                ),
                'pid_numbers' => array(
                    'description' => 'The numeric values to combine with the namespace to generate pids to take action on',
                    'required' => 'true'
                ),
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
            ),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_migrate_delete_datastream',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );
        $items['ucla_add_dataStream_to_digitalObject'] = array(
            'callback' => 'add_dataStream_to_digitalObject',
            'description' => 'Ingest content given digital assets but no metadata files.',
            'options' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
                'manifest_file_path' => array(
                    'description' => 'The path to the file containing a list of assets to ingest.',
                    'required' => 'true'
                ),
                'digitalObject' => array(
                    'description' => 'Provide one of following choices (MODS,TIFF,JPEG,PDF,VIDEO,TEI,TN)',
                    'required' => 'true'
                ),

            ),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_add_dataStream_to_digitalObject --fedora_namespace=fedoranamespace --manifest_file_path=/path/to/manifest/file.txt --digitalObject=MODS',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );
        $items['ucla_migrate_min_metadata'] = array(
            'callback' => 'minimum_metadata_ingest',
            'description' => 'Ingest content given digital assets but no metadata files.',
            'options' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
                'manifest_file_path' => array(
                    'description' => 'The path to the file containing a list of assets to ingest.',
                    'required' => 'true'
                ),
                'overwrite' => array(
                    'description' => 'If true, remove existing Fedora objects in the namespace with the same filename/title.',
                    'required' => 'true'
                ),
                'digitalObject' => array(
                    'description' => 'Provide one of following choices (MODS,TIFF,JPEG,PDF,VIDEO,TN)',
                    'required' => 'true'
                ),
            ),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_migrate_min_medatata fedoranamespace /path/to/manifest/file.txt --digitalObject=TIFF',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_share_objects'] = array(
            'callback' => 'share_objects_between_collection',
            'description' => 'This will ingest objects in more than 1 collection',
            'options' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
                'manifest_file_path' => array(
                    'description' => 'The path to the file containing a list of assets to ingest.',
                    'required' => 'true'
                ),
                'overwrite' => array(
                    'description' => 'If true, remove existing Fedora objects in the namespace with the same filename/title.',
                    'required' => 'true'
                ),
                'digitalObject' => array(
                    'description' => 'Provide one of following choices (MODS,TIFF,JPEG,PDF,VIDEO,TN)',
                    'required' => 'true'
                ),

                'sharedCollection' => array(
                    'description' => 'comma separated collection pids',
                    'required' => 'true'
                ),

            ),
            'examples' => array(
                'simple example' => 'drush -u 1 -l  ucla_share_objects fedoranamespace: manifest_file_path:/path/to/manifest/file.txt --digitalObject=TIFF --sharedCollection:cubanephemera,latinamericanandcaribbeanperiodicals',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );
        $items['ucla_fix_page_sequence_number'] = array(
            'callback' => 'fix_page_sequence_number',
            'description' => 'Ingest content given digital assets but no metadata files.',
            'options' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
                'manifest_file_path' => array(
                    'description' => 'The path to the file containing a list of assets to ingest.',
                    'required' => 'true'
                ),
            ),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_fix_page_sequence_number fedoranamespace /path/to/manifest/file.txt',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );
        $items['ucla_add_children_to_manuscript'] = array(
            'callback' => 'add_children_to_manuscript',
            'description' => 'Ingest content given digital assets but no metadata files.',
            'options' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
                'manifest_file_path' => array(
                    'description' => 'The path to the file containing a list of assets to ingest.',
                    'required' => 'true'
                ),
                'digitalObject' => array(
                    'description' => 'Provide one of following choices (MODS,TIFF,JPEG,PDF,VIDEO)',
                    'required' => 'true'
                ),
            ),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_add_children_to_manuscript fedoranamespace /path/to/manifest/file.txt --digitalObject=PDF',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );
        $items['ucla_add_children_to_compound_object'] = array(
            'callback' => 'add_children_to_compound_object',
            'description' => 'Ingest content given digital assets but no metadata files.',
            'options' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
                'manifest_file_path' => array(
                    'description' => 'The path to the file containing a list of assets to ingest.',
                    'required' => 'true'
                ),
                'digitalObject' => array(
                    'description' => 'Provide one of following choices (MODS,TIFF,JPEG,PDF,VIDEO)',
                    'required' => 'true'
                ),
            ),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_add_children_to_compound_object fedoranamespace /path/to/manifest/file.txt digitalObect',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );
        $items['ucla_migrate_mp4_with_mods'] = array(
            'callback' => 'mp4_ingest_with_mods',
            'description' => 'Ingest content given digital assets with mods files.',
            'options' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
                'manifest_file_path' => array(
                    'description' => 'The path to the file containing a list of assets to ingest.',
                    'required' => 'true'
                ),
                'overwrite' => array(
                    'description' => 'If true, remove existing Fedora objects in the namespace with the same filename/title.',
                    'required' => 'true'
                ),
            ),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_migrate_mp4_with_mods fedoranamespace /path/to/manifest/file.txt',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_migrate_images_with_mods'] = array(
            'callback' => 'images_ingest_with_mods',
            'description' => 'Ingest content given digital assets with mods files.',
            'options' => array(
                'fedora_namespace' => array(
                    'description' => 'The Fedora namespace to update the datastreams under.',
                    'required' => 'true'
                ),
                'manifest_file_path' => array(
                    'description' => 'The path to the file containing a list of assets to ingest. This is should be the mods file name and location',
                    'required' => 'true'
                ),
                'overwrite' => array(
                    'description' => 'If true, remove existing Fedora objects in the namespace with the same filename/title.',
                    'required' => 'true'
                ),
            ),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_migrate_images_with_mods fedoranamespace /path/to/manifest/file.txt',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );

        $items['ucla_migrate_add_items_to_collection'] = array(
            'callback' => 'add_items_to_collection',
            'description' => 'Add completed Fedora items to a specified collection.',
            'options' => array(
                'fedora_dest_collection' => array(
                    'description' => 'The Fedora namespace of the destination collection to add the items to.',
                    'required' => 'true'
                ),
                'manifest_file_path' => array(
                    'description' => 'The path to the file containing a list of PIDs to add to to the specified collection.',
                    'required' => 'true'
                ),
            ),
            'examples' => array(
                'simple example' => 'drush -u 1 -l http://example.com ucla_migrate_add_items_to_collection fedora_dest_collection /path/to/manifest/file.txt',
            ),
            'bootstrap' => DRUSH_BOOTSTRAP_DRUPAL_LOGIN,
        );


        return $items;
    }

    function fix_fedoraObject_relsExt_by_pids() {
        $pids = drush_get_option('pids');
        if (!isset($pids)) {
            drush_set_error('Pids not provided', 'A pids to associate with the ingest must be provided', 'Error: ');
            return;
        }



        $pids_file = file($pids, FILE_IGNORE_NEW_LINES);
        if (!$pids_file) {
            drush_set_error('File not found', "Could not locate manifest file file $pids", "Error: ");
            return;
        }


        foreach ($pids_file as $pid) {


            //$pid = trim($pid);
            $object = islandora_object_load(trim($pid));
            if (isset($object)) {
                $object_content_models = $object->relationships->get('info:fedora/fedora-system:def/model#', 'hasModel');

                $hasModelManuscriptCModel = FALSE;
                foreach ($object_content_models as $model) {
                    watchdog('UCLA Migration', "has Model Object @results", array('@results' => $model), WATCHDOG_NOTICE);
                    if ($model['object']['value'] == 'islandora:manuscriptCModel') {
                        $hasModelManuscriptCModel = TRUE;
                        break;
                    }
                }
                if ($hasModelManuscriptCModel == FALSE) {
                    $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:manuscriptCModel');
                }
            }
        }
    }


    function fix_fedoraObject_metadata_by_pids() {
        $pids = drush_get_option('pids');
        if (!isset($pids)) {
            drush_set_error('Pids not provided', 'A pids to associate with the ingest must be provided', 'Error: ');
            return;
        }
        $metadata_value = drush_get_option('metadata_value');
        if (!isset($metadata_value)) {
            drush_set_error('metadata_value needs to be provided to determine which xslt to be used eg: video recordings ', 'G', 'Error: ');
            return;
        }

        $pids_file = file($pids, FILE_IGNORE_NEW_LINES);
        if (!$pids_file) {
            drush_set_error('File not found', "Could not locate manifest file $pids", "Error: ");
            return;
        }


        foreach ($pids_file as $pid) {


            //$pid = trim($pid);
            $object = islandora_object_load(trim($pid));
            if (isset($object)) {
                if (!isset($object['MODS']) || empty($object['MODS'])) {
                    watchdog('UCLA Migration', "begin  No mods @results", array('@results' => $object->id), WATCHDOG_ERROR);
                } else {

                    $mods_txt = $object['MODS']->content;
                    ucla_migration_add_genre_to_mods($object, $mods_txt, $metadata_value);
                }
            }
        }
    }



    function add_program_idep_to_metadata_by_namespace($fedora_namespace) {

      if (!isset($fedora_namespace)) {
          return drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
      }
      // Get a connection to Fedora.
      $connection = islandora_get_tuque_connection();
      // SPARQL query to get all objects in a given namespace.
      $base_query = <<<EOQ
    SELECT DISTINCT ?obj
    WHERE {
      ?obj <info:fedora/fedora-system:def/model#hasModel> <info:fedora/fedora-system:FedoraObject-3.0> .
      !filter
    } ORDER BY ?obj
EOQ;
      $query = format_string($base_query, array(
        '!filter' => "FILTER(regex(str(?obj), '^info:fedora/" . $fedora_namespace . "'))",
      ));
      // Execute the query.
      $results = $connection->repository->ri->sparqlQuery($query);

      watchdog('UCLA Migration', "begin 2", WATCHDOG_NOTICE);

      foreach ($results as $result) {
        watchdog('UCLA Migration', "begin 3 @pid", array('@pid' => $result['obj']['value']), WATCHDOG_NOTICE);

        if ($result['obj']['value'] !== $fedora_namespace . ':1') {
          $object = islandora_object_load($result['obj']['value']);

          if ($object) {
            if (isset($object['MODS']) && !empty($object['MODS'])) {
              $mods_txt = $object['MODS']->content;
              ucla_migration_add_program_to_mods($object, $mods_txt);
            }
            else {
              watchdog('UCLA Migration', "begin No mods @pid", array('@pid' => $object->id), WATCHDOG_ERROR);
            }
          }
          else {
            watchdog('UCLA Migration', "begin Error loading object @pid", array('@pid' => $result['obj']['value']), WATCHDOG_ERROR);
          }
        }
      }
    }



    function add_program_idep_to_metadata_by_PIDS($pids) {

        if (!isset($pids)) {
            drush_set_error('Pids not provided', 'A pids to associate with the ingest must be provided', 'Error: ');
            return;
        }


        $pids_file = file($pids, FILE_IGNORE_NEW_LINES);
        if (!$pids_file) {
            drush_set_error('File not found', "Could not locate manifest file $pids", "Error: ");
            return;
        }


        foreach ($pids_file as $pid) {
            $object = islandora_object_load(trim($pid));
            if ($object) {
                if (isset($object['MODS']) && !empty($object['MODS'])) {
                    $mods_txt = $object['MODS']->content;
                    ucla_migration_add_program_to_mods($object, $mods_txt);
                }
                else {
                    watchdog('UCLA Migration', "begin No mods @pid", array('@pid' => $object->id), WATCHDOG_ERROR);
                }
            } else {
                watchdog('UCLA Migration', "begin Error loading object @pid", array('@pid' => $pid), WATCHDOG_ERROR);
            }
        }

    /*    // Get a connection to Fedora.
        $connection = islandora_get_tuque_connection();
        // SPARQL query to get all objects in a given namespace.
        $base_query = <<<EOQ
    SELECT DISTINCT ?obj
    WHERE {
      ?obj <info:fedora/fedora-system:def/model#hasModel> <info:fedora/fedora-system:FedoraObject-3.0> .
      !filter
    } ORDER BY ?obj
    EOQ;
        $query = format_string($base_query, array(
            '!filter' => "FILTER(regex(str(?obj), '^info:fedora/" . $fedora_namespace . "'))",
        ));
        // Execute the query.
        $results = $connection->repository->ri->sparqlQuery($query);*/


    }


    function update_metadata_for_mods_by_pids($pids,$old_metadata_value,$local_name,$new_metadata_value) {
        // $pids = drush_get_option('pids');
        if (!isset($pids)) {
            drush_set_error('Pids not provided', 'A pids to associate with the ingest must be provided', 'Error: ');
            return;
        }
        //$metadata_value = drush_get_option('metadata_value');
        if (!isset($old_metadata_value)) {
            drush_set_error('metadata_value needs to be provided to determine which value to be updated eg: Newspapers ', 'G', 'Error: ');
            return;
        }

        if (!isset($new_metadata_value)) {
            drush_set_error('metadata_value needs to be provided to determine which value to update to eg: newspapers ', 'G', 'Error: ');
            return;
        }

        if (!isset($local_name)) {
            drush_set_error('local_name needs to be provided to determine which mods elements will be updated eg genre', 'G', 'Error: ');
            return;
        }


        $pids_file = file($pids, FILE_IGNORE_NEW_LINES);
        if (!$pids_file) {
            drush_set_error('File not found', "Could not locate manifest file $pids", "Error: ");
            return;
        }


        foreach ($pids_file as $pid) {


            //$pid = trim($pid);
            $object = islandora_object_load(trim($pid));
            if (isset($object)) {
                if (!isset($object['MODS']) || empty($object['MODS'])) {
                    watchdog('UCLA Migration', "begin  No mods @results", array('@results' => $object->id), WATCHDOG_ERROR);
                } else {

                    $mods_txt = $object['MODS']->content;
                    ucla_migration_update_metadata_from_mods($object, $mods_txt, $old_metadata_value, $new_metadata_value, $local_name);
                }
            }
        }
    }

    function delete_mods_element_by_pids($pids,$local_name) {
        // $pids = drush_get_option('pids');
        if (!isset($pids)) {
            drush_set_error('Pids not provided', 'A pids to associate with the ingest must be provided', 'Error: ');
            return;
        }
        //$metadata_value = drush_get_option('metadata_value');
        if (!isset($local_name)) {
            drush_set_error('metadata_value needs to be provided to determine which xslt to be used eg: video recordings ', 'G', 'Error: ');
            return;
        }

        $pids_file = file($pids, FILE_IGNORE_NEW_LINES);
        if (!$pids_file) {
            drush_set_error('File not found', "Could not locate manifest file $pids", "Error: ");
            return;
        }


        foreach ($pids_file as $pid) {


            //$pid = trim($pid);
            $object = islandora_object_load(trim($pid));
            if (isset($object)) {
                if (!isset($object['MODS']) || empty($object['MODS'])) {
                    watchdog('UCLA Migration', "begin  No mods @results", array('@results' => $object->id), WATCHDOG_ERROR);
                } else {

                    $mods_txt = $object['MODS']->content;
                    ucla_migration_delete_element_from_mods($object, $mods_txt, $local_name);
                }
            }
        }
    }
    /**
     * Saves all pids in a Fedora namespace to a file.
     *
     * This is done so ucla_make_namespace_versionable can have a list of all pids
     * for the given namespace after Fedora's resource index gets disabled.  Output
     * file is written to the ucla_migration module folder.  It is given the name
     * of the fedora namespace and an extension of '.pid'.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace whose PIDS you want.
     */
    function ucla_migration_save_pids_for_namespace($fedora_namespace) {
        // Get a connection to Fedora.
        $connection = islandora_get_tuque_connection();
        $repo = $connection->repository;

        // SPARQL query to get all objects in a given namespace.
        $query = "
        SELECT ?obj
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:'))
        }
      ";

        // Execute the query.
        $results = $repo->ri->sparqlQuery($query);

        // Put all the pids in an array.
        $pids = array();
        foreach ($results as $result) {
            array_push($pids, $result['obj']['value']);
        }

        // JSON encode the array and write it to a file.
        $path = DRUPAL_ROOT . '/' . drupal_get_path('module', 'ucla_migration') . "/$fedora_namespace.pids";
        $fp = fopen($path, 'w');
        if (!$fp) {
            drush_set_error("Can't open file to write", "Cannot open file $path to write.  Check your permissions for the ucla_migration module folder or run this script using sudo.", "Error: "
            );
            return;
        }

        if (!fwrite($fp, json_encode($pids))) {
            drush_set_error("Can't write pids to file", "Cannot write pids to $path.  Check your permissions for the ucla_migration module folder or run this script using sudo.", "Error: "
            );
            fclose($fp);
            return;
        }

        fclose($fp);
        return;
    }


    /**
     *
     * @param type $fedora_namespace
     *  The namespace in Fedora to relate as the collection parent for the
     *  import
     *
     *
     */
    function update_Label_from_DC_for_namespace() {



        $fedora_namespace = drush_get_option('fedora_namespace');
        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }

        // Get a connection to Fedora.
        $connection = islandora_get_tuque_connection();
        $repo = $connection->repository;

        // SPARQL query to get all objects in a given namespace.
        $query = "
        SELECT ?obj
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:'))
        }
      ";

        // Execute the query.
        $results = $repo->ri->sparqlQuery($query);
        watchdog('UCLA Migration', "begin 2 @results", array('@results' => $results), WATCHDOG_NOTICE);

        foreach ($results as $result) {
            watchdog('UCLA Migration', "begin 3 @results", array('@results' => $result['obj']['value']), WATCHDOG_NOTICE);
            if ($result['obj']['value'] !== $fedora_namespace . ':1') {
                watchdog('UCLA Migration', "begin 4 @results", array('@results' => $result['obj']['value']), WATCHDOG_NOTICE);
                $object = islandora_object_load($result['obj']['value']);
                $dc_txt = $object['DC']->content;
                $dc_xml = simplexml_load_string($dc_txt);

                // Register namespaces of the root element.
                $xml_namespaces = $dc_xml->getDocNamespaces();
                $dc_xml->registerXPathNamespace('oai_dc', $xml_namespaces['oai_dc']);
                $dc_xml->registerXPathNamespace('dc', $xml_namespaces['dc']);
                watchdog('UCLA Migration', "begin Label @results", array('@results' => $object->label), WATCHDOG_NOTICE);
                $dc_query = "//dc:title[1]";
                $dc_array = $dc_xml->xpath($dc_query);
                watchdog('UCLA Migration', "begin dc title @results", array('@results' => $dc_array[0]->__toString()), WATCHDOG_NOTICE);

                $object->label = $dc_array[0]->__toString();
            }
        }
    }

    /**
     *
     * @param type $pids
     *  The namespace in Fedora to relate as the collection parent for the
     *  import
     *
     *
     */
    function update_Label_from_DC_for_PIDS() {


        $pids = drush_get_option('pids');
        if (!isset($pids)) {
            drush_set_error('Pids not provided', 'A pids to associate with the ingest must be provided', 'Error: ');
            return;
        }

        $pids_file = file($pids, FILE_IGNORE_NEW_LINES);
        if (!$pids_file) {
            drush_set_error('File not found', "Could not locate manifest file $pids", "Error: ");
            return;
        }


        foreach ($pids_file as $pid) {
            //$pid = trim($pid);
            $object = islandora_object_load(trim($pid));
            if (isset($object)) {


                $dc_txt = $object['DC']->content;
                $dc_xml = simplexml_load_string($dc_txt);

                // Register namespaces of the root element.
                $xml_namespaces = $dc_xml->getDocNamespaces();
                $dc_xml->registerXPathNamespace('oai_dc', $xml_namespaces['oai_dc']);
                $dc_xml->registerXPathNamespace('dc', $xml_namespaces['dc']);
                watchdog('UCLA Migration', "begin Label @results", array('@results' => $object->label), WATCHDOG_NOTICE);
                $dc_query = "//dc:title[1]";
                $dc_array = $dc_xml->xpath($dc_query);
                watchdog('UCLA Migration', "begin dc title @results", array('@results' => $dc_array[0]->__toString()), WATCHDOG_NOTICE);

                $object->label = $dc_array[0]->__toString();



            }
        }

    }




    function add_genre_to_MODS_for_namespace(){
        $fedora_namespace = drush_get_option('fedora_namespace');






        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }





        // Get a connection to Fedora.
        $connection = islandora_get_tuque_connection();
        $repo = $connection->repository;

        // SPARQL query to get all objects in a given namespace.
        $query = "
        SELECT ?obj
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:'))
        }
      ";

        // Execute the query.
        $results = $repo->ri->sparqlQuery($query);
        watchdog('UCLA Migration', "begin 2 @results", array('@results' => $results), WATCHDOG_NOTICE);
        foreach ($results as $result) {
            watchdog('UCLA Migration', "begin 3 @results", array('@results' => $result['obj']['value']), WATCHDOG_NOTICE);
            if ($result['obj']['value'] !== $fedora_namespace . ':1') {
                watchdog('UCLA Migration', "begin 4 @results", array('@results' => $result['obj']['value']), WATCHDOG_NOTICE);
                $object = islandora_object_load($result['obj']['value']);


                if (!isset($object['MODS']) || empty($object['MODS'])) {
                    watchdog('UCLA Migration', "begin  No mods @results", array('@results' => $result['obj']['value']), WATCHDOG_ERROR);
                } else {

                    $mods_txt = $object['MODS']->content;
                    ucla_migration_add_genre_to_mods($object, $mods_txt, "per_video_genre");
                }
            }
        }
    }

    /**
     *
     * @param type $fedora_namespace
     *  The namespace in Fedora to relate as the collection parent for the
     *  import
     *
     *
     */
    function update_DC_from_MODS_for_namespace($fedora_namespace) {
        //$fedora_namespace = drush_get_option('fedora_namespace');






        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }



        watchdog('UCLA Migration', "begin @results", array('@results' => $fedora_namespace), WATCHDOG_NOTICE);

        // Get a connection to Fedora.
        $connection = islandora_get_tuque_connection();
        $repo = $connection->repository;

        // SPARQL query to get all objects in a given namespace.
        $query = "
        SELECT ?obj
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:'))
        }
      ";

        // Execute the query.
        $results = $repo->ri->sparqlQuery($query);
        watchdog('UCLA Migration', "begin 2 @results", array('@results' => $results), WATCHDOG_NOTICE);

        foreach ($results as $result) {
            watchdog('UCLA Migration', "begin 3 @results", array('@results' => $result['obj']['value']), WATCHDOG_NOTICE);
            if ($result['obj']['value'] !== $fedora_namespace . ':1') {
                watchdog('UCLA Migration', "begin 4 @results", array('@results' => $result['obj']['value']), WATCHDOG_NOTICE);
                $object = islandora_object_load($result['obj']['value']);


                if (!isset($object['MODS']) || empty($object['MODS'])) {
                    watchdog('UCLA Migration', "begin  No mods @results", array('@results' => $result['obj']['value']), WATCHDOG_ERROR);
                    file_put_contents('NoModsObjects'.date("Y-m-d").'.txt',$result['obj']['value'], FILE_APPEND);
                } else {

                    $mods_txt = $object['MODS']->content;
                    ucla_migration_add_dc_to_object_from_mods($object, $mods_txt);
                }
            }
        }
    }

    /**
     *
     * @param type $pids
     *  The namespace in Fedora to relate as the collection parent for the
     *  import
     *
     *
     */
    function update_DC_from_MODS_for_PIDS($pids) {


        //$pids = drush_get_option('pids');
        if (!isset($pids)) {
            drush_set_error('Pids not provided', 'A pids to associate with the ingest must be provided', 'Error: ');
            return;
        }


        $pids_file = file($pids, FILE_IGNORE_NEW_LINES);
        if (!$pids_file) {
            drush_set_error('File not found', "Could not locate manifest file $pids", "Error: ");
            return;
        }


        foreach ($pids_file as $pid) {
            //$pid = trim($pid);
            $object = islandora_object_load(trim($pid));
            if (!isset($object['MODS']) || empty($object['MODS'])) {
                watchdog('UCLA Migration', "begin  No mods @results", array('@results' => $object->id), WATCHDOG_ERROR);
            } else {

                $mods_txt = $object['MODS']->content;
                ucla_migration_add_dc_to_object_from_mods($object, $mods_txt);
            }
        }


    }

    /**
     * Sets all datastreams for all objects in a Fedora namespace to versionable.
     *
     * Reads in the output of ucla_migration_save_pids_for_namespace because this
     * cannot be run with Fedora's resource index enabled.  Be sure to execute the
     * ucla_save_pids_for_namespace Drush command first, then disable the resource
     * index and restart Fedora.  Then run this command.  Then re-enable the
     * resource index and restart Fedora again.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace whose datastreams you want to fix.
     */
    function ucla_migration_make_all_datastreams_versionable($fedora_namespace) {
        // Open up the pid file to read.
        $path = DRUPAL_ROOT . '/' . drupal_get_path('module', 'ucla_migration') . "/$fedora_namespace.pids";
        $fp = fopen($path, 'r');

        if (!$fp) {
            drush_set_error("Can't open file to read", "Cannot open file $path to read.  Does it exist?  Check your permissions for the ucla_migration module folder or run this script using sudo.", "Error: "
            );
            return;
        }

        // Grab its contents.
        $contents = fread($fp, filesize($path));
        if (!$contents) {
            drush_set_error("Can't read file contents.", "Cannot read contents of $path.  Does it exist?  Check your permissions for the ucla_migration module folder or run this script using sudo.", "Error: "
            );
            fclose($fp);
            return;
        }

        // Close the file pointer so we're not leaking all over the place.
        fclose($fp);

        // JSON decode the array of pids.
        $pids = json_decode($contents);

        // Set each datastream for each object in the namespace to versionable.
        foreach ($pids as $pid) {
            $obj = islandora_object_load($pid);
            foreach ($obj as $dsid => $dsObj) {
                $dsObj->versionable = TRUE;
            }
        }
    }

    /**
     * Migrates all records in a METS file.
     *
     * Executes the migration based on a mets file.  Can recover a previously
     * failed ingest if the numeric portion of the last successfully ingested
     * object is provided as a command line argument.
     *
     * @param string $file_path
     *   The path to the mets file serving as the manifest for this ingest.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @param string $recovery_number
     *   The number portion of the PID from the last successfully ingested object.
     */
    function ucla_migration_migrate_mets($file_path, $fedora_namespace, $recovery_number = 0) {
        // Check to make sure the path to the mets file has been provided.
        if (!isset($file_path)) {
            drush_set_error('File path not provided', 'Path to mets file not provided as command line argument', 'Error: ');
            return;
        }

        // Attempt to grab the mets file.
        $mets_file = file_get_contents($file_path);
        if (!$mets_file) {
            drush_set_error('File not found', "Could not locate mets file $file_path", "Error: ");
            return;
        }

        $mets_xml = simplexml_load_string($mets_file);

        // Register namespaces of the root element.
        $xml_namespaces = $mets_xml->getDocNamespaces();
        $mets_xml->registerXPathNamespace('mets', $xml_namespaces['mets']);
        $mets_xml->registerXPathNamespace('xlink', $xml_namespaces['xlink']);

        // Either start a new migration, or recover a previously failed one,
        // whichever is appropriate.
        $results = FALSE;
        if ($recovery_number < 1) {
            $results = ucla_migration_start_new_migration($mets_xml, $fedora_namespace);
        } else {
            $results = ucla_migration_recover_migration($mets_xml, $fedora_namespace, $recovery_number);
        }

        // Final message to user.
        if ($results) {
            drush_log("Successfully migrated {$fedora_namespace} collection.", 'ok');
        } else {
            drush_log("Failed to migrate {$fedora_namespace} collection.  Check the watchdog logs for more info.", 'error');
        }

        return;
    }

    /**
     * Starts a new migration from scratch.
     *
     * Executes the migration based on a mets file.  Objects are ingested under the
     * supplied namespace.
     *
     * @param SimpleXMLElement $mets_xml
     *   SimpleXML object that represents the mets file from the path provided to
     *   the drush script.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @return bool
     *   Returns TRUE if success, FALSE if error.
     */
    function ucla_migration_start_new_migration($mets_xml, $fedora_namespace) {
        // Create the collection first.
        $collection = ucla_migration_migrate_collection_object($fedora_namespace, $mets_xml);

        // Exit if ingest of collection object failed.
        if (!$collection) {
            watchdog('UCLA Migration', 'Collection object ingest failed.', array(), WATCHDOG_ERROR);
            return FALSE;
        }

        return ucla_migration_migrate_all_children($fedora_namespace, $mets_xml, $collection);
    }

    /**
     * Recovers a failed migration.
     *
     * Starting with the last successfully ingested object, objects from the mets
     * xmls are ingested into the supplied namespace.
     *
     * @param SimpleXMLElement $mets_xml
     *   SimpleXML object that represents the mets file from the path provided to
     *   the drush script.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @param string $recovery_number
     *   The number portion of the PID from the last successfully ingested object.
     *
     * @return bool
     *   Returns TRUE if success, FALSE if error.
     */
    function ucla_migration_recover_migration($mets_xml, $fedora_namespace, $recovery_number) {
        module_load_include('inc', 'islandora', 'includes/utilities');

        // Attempt to get the object specified by the recovery number,
        // that is, the last successfully ingested object.
        $last_good_pid = $fedora_namespace . ":" . $recovery_number;
        $last_good_object = islandora_object_load($last_good_pid);

        // Validate.
        if (is_null($last_good_object)) {
            watchdog('UCLA Migration', 'Could not find last successfully ingested object with pid @pid', array('@pid' => $last_good_pid), WATCHDOG_ERROR);
            return FALSE;
        }

        // Get the parents of the last good object.
        $parents = islandora_get_parents_from_rels_ext($last_good_object);

        // Validate.
        if (empty($parents)) {
            watchdog('UCLA Migration', 'Could not find parents of @pid, the last successfully ingested object.', array('@pid' => $last_good_pid), WATCHDOG_ERROR);
            return FALSE;
        }

        if (count($parents) > 1) {
            watchdog('UCLA Migration', 'Found more than one parent for @pid, the last successfully ingested object.', array('@pid' => $last_good_pid), WATCHDOG_ERROR);
            return FALSE;
        }

        // Unbox the parent.
        $parent = $parents[0];

        // Migrate all the children if the parent id is the root collection.  This
        // would indicate that only the collection object has been ingested, so
        // basically start over.
        if ($parent->id == "islandora:root") {
            return ucla_migration_migrate_all_children($fedora_namespace, $mets_xml, $parent);
        }
        // Otherwise recover starting with the object after the last successfully
        // ingested object.
        else {
            $starting_pid = $fedora_namespace . ":" . ($recovery_number + 1);
            return ucla_migration_migrate_children_after($fedora_namespace, $mets_xml, $parent, $last_good_object, $starting_pid);
        }
    }

    /**
     * Migrates a single object based on record ID.
     *
     * @param string $file_path
     *   The path to the mets file serving as the manifest for this ingest.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @param string $dmdid
     *   The record ID provided in the MODS for the record to migrate.
     */
    function ucla_migration_migrate_from_dmdid($file_path, $fedora_namespace, $dmdid) {
        // Check to make sure the path to the mets file has been provided.
        if (!isset($file_path)) {
            drush_set_error('File path not provided', 'Path to mets file not provided as command line argument', 'Error: ');
            return;
        }

        // Attempt to grab the mets file.
        $mets_file = file_get_contents($file_path);
        if (!$mets_file) {
            drush_set_error('File not found', "Could not locate mets file $file_path", "Error: ");
            return;
        }

        $mets_xml = simplexml_load_string($mets_file);

        // Register namespaces of the root element.
        $xml_namespaces = $mets_xml->getDocNamespaces();
        $mets_xml->registerXPathNamespace('mets', $xml_namespaces['mets']);
        $mets_xml->registerXPathNamespace('xlink', $xml_namespaces['xlink']);

        // Get the collection object.
        // Probably a bad assumption, but it'll work for now.
        $collection = islandora_object_load($fedora_namespace . ":1");

        if (!$collection) {
            drush_set_error('No Collection Object', 'Could not load collection object.  Perhaps the fedora namespace is wrong, or the collection object is not the first object in the namespace.', 'Error: ');
            return;
        }

        // Query for the tiff file.
        $dmdid = "DMD-" . $dmdid;
        $image_query = "//mets:div[@TYPE='Image' and @DMDID='$dmdid']";
        $image_array = $mets_xml->xpath($image_query);

        // Validate results.
        if (!is_array($image_array)) {
            drush_set_error('XPath Error', "Error in XPath query $image_query", "Error: ");
            return;
        }

        if (empty($image_array)) {
            drush_set_error('XPath Error', "No results for XPath query $image_query", "Error: ");
            return;
        }

        if (count($image_array) > 1) {
            drush_set_error('XPath Error', "Multiple results for XPath query $image_query", "Error: ");
            return;
        }

        $results = ucla_migration_migrate_child_object($fedora_namespace, $image_array[0], $mets_xml, $collection);

        // Final message to user.
        if (!$results) {
            drush_set_error('Migration error', "Error migrating object from dmdid $dmdid", "Error: ");
            return;
        }

        drush_log("Migration success.  Check watchdog logs for more information.", 'ok');

        return;
    }

    /**
     * Migrates the main collection object for the provided mets xml.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @param SimpleXMLElement $mets_xml
     *   SimpleXML object that represents the mets file from the path provided to
     *   the drush script.
     *
     * @return NewFedoraObject
     *   The newly ingested collection object.  Returns FALSE if there is an error
     *   at any point in the process.
     */
    function ucla_migration_migrate_collection_object($fedora_namespace, $mets_xml) {
        // Query for id.
        $collection_id_section_query = "//mets:div[@TYPE='Collection']";
        $collection_id_section_array = $mets_xml->xpath($collection_id_section_query);

        // Validate results.
        if (!is_array($collection_id_section_array)) {
            watchdog('UCLA Migration', "Error in XPath query @query", array('@query' => $collection_id_section_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (empty($collection_id_section_array)) {
            watchdog('UCLA Migration', "No results for XPath query @query", array('@query' => $collection_id_section_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (count($collection_id_section_array) > 1) {
            watchdog('UCLA Migration', "More than one result for XPath query @query", array('@query' => $collection_id_section_query), WATCHDOG_ERROR);
            return FALSE;
        }

        // Actually get the id.
        $collection_id = $collection_id_section_array[0]['DMDID'];

        // Query for the collection based on id.
        $collection_section_query = "//mets:dmdSec[@ID='$collection_id']";
        $collection_section_array = $mets_xml->xpath($collection_section_query);

        // Validate results.
        if (!is_array($collection_id_section_array)) {
            watchdog('UCLA Migration', "Error in XPath query @query", array('@query' => $collection_section_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (empty($collection_id_section_array)) {
            watchdog('UCLA Migration', "No results for XPath query @query", array('@query' => $collection_section_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (count($collection_id_section_array) > 1) {
            watchdog('UCLA Migration', "More than one result for XPath query @query", array('@query' => $collection_section_query), WATCHDOG_ERROR);
            return FALSE;
        }

        // Get the children elements of the collection section that have a mets
        // namespace.
        $xml_namespaces = $mets_xml->getDocNamespaces();
        $collection_section = $collection_section_array[0]->children($xml_namespaces['mets']);

        // Validate.
        if ($collection_section->count() == 0) {
            watchdog('UCLA Migration', "Could not locate mdWrap element for @id in the METS.", array('@id' => $collection_id), WATCHDOG_ERROR);
            return FALSE;
        }

        if ($collection_section->count() > 1) {
            watchdog('UCLA Migration', "Multiple mdWrap elements for @id in the METS.", array('@id' => $collection_id), WATCHDOG_ERROR);
            return FALSE;
        }

        // Grab the collection label.
        $collection_label = $collection_section->mdWrap->attributes()->LABEL;

        // Get the children elements of the collection section that have a mods
        // namespace.  We didn't register this namespace because it's not in the root
        // element, so we just use it manually.
        $collection_mods = $collection_section->mdWrap->xmlData->children('http://www.loc.gov/mods/v3');

        // Validate.
        if ($collection_mods->count() == 0) {
            watchdog('UCLA Migration', "Could not locate mods element for @id in the METS.", array('@id' => $collection_id), WATCHDOG_ERROR);
            return FALSE;
        }

        if ($collection_mods->count() > 1) {
            watchdog('UCLA Migration', "Multiple mods elements for @id in the METS.", array('@id' => $collection_id), WATCHDOG_ERROR);
            return FALSE;
        }

        // Grab the mods string.
        $mods_string = $collection_mods->mods->asXML();
        // Clean it up by adding the xsi namespace so SimpleXML and DOMDocument don't
        // cry every time something is done with the MODS.  The namespaces is in the
        // root node of the mets, but not the root node of the MODS.  So we'll just
        // add it in here for completeness.
        $mods_string = ucla_migration_add_xsi_namespace_to_mods_txt($mods_string);

        // Create the NewFedoraObject for the collection.
        $collection = ucla_migration_create_collection_object(
            $fedora_namespace, $collection_label, $mods_string);

        // Ingest the NewFedoraObject.
        $ingest_results = islandora_add_object($collection);

        // Validate.
        if (!$ingest_results) {
            watchdog('UCLA Migration', "Ingest for the collection object has failed.", array(), WATCHDOG_ERROR);
            return FALSE;
        }

        watchdog('UCLA Migration', "Ingested @id.", array('@id' => $collection->id), WATCHDOG_INFO);

        // Return the ingested object.
        return $ingest_results;
    }

    /**
     * Migrates all children of the collection object in the provided mets xml.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @param SimpleXMLElement $mets_xml
     *   SimpleXML object that represents the mets file from the path provided to
     *   the drush script.
     *
     * @param NewFedoraObject $collection
     *   The collection this child will be a member of.
     *
     * @return bool
     *   Returns TRUE if succesful, FALSE if error.
     */
    function ucla_migration_migrate_all_children($fedora_namespace, $mets_xml, $collection) {
        // Get all the children objects.  Each one will correspond to a tiff file.
        $image_array = ucla_migration_get_all_children_xmls($mets_xml);

        // Exit early if there are no children.
        if (empty($image_array)) {
            return FALSE;
        }

        // Iterate over the query results, making and ingesting a child object for
        // each tiff.
        $ingest_success = TRUE;
        for ($i = 0; $i < count($image_array) && $ingest_success; $i++) {
            $ingest_success = ucla_migration_migrate_child_object($fedora_namespace, $image_array[$i], $mets_xml, $collection);
            if ($ingest_success) {
                watchdog('UCLA Migration', 'Migrated object @idx out of @total', array(
                    '@idx' => $i + 1,
                    '@total' => count($image_array)
                ), WATCHDOG_INFO);
            }
        }

        // Exit if ingest of any child object failed.
        if (!$ingest_success) {
            watchdog('UCLA Migration', 'Child object ingest failed.', array(), WATCHDOG_ERROR);
            return FALSE;
        }

        return TRUE;
    }

    /**
     * Migrates all children after the supplied object in mets xml.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @param SimpleXMLElement $mets_xml
     *   SimpleXML object that represents the mets file from the path provided to
     *   the drush script.
     *
     * @param NewFedoraObject $collection
     *   The collection this child will be a member of.
     *
     * @param NewFedoraObject $last_good_object
     *   The last successfully ingested object from the previous migration attempt.
     *
     * @return bool
     *   Returns TRUE if successful, FALSE if there is an error.
     */
    function ucla_migration_migrate_children_after($fedora_namespace, $mets_xml, $collection, $last_good_object, $starting_pid) {
        // Try to delete the object AFTER the last successfully ingested object.  If
        // it exists, it's defnitely broken, so let's get rid of it before restarting
        // the migration.
        $starting_object = islandora_object_load($starting_pid);

        if (isset($starting_object) && $starting_object) {
            islandora_delete_object($starting_object);
        }

        // Get the last successfully ingested object's id (not PID, this comes from
        // the MODS).
        $last_good_record_id = ucla_migration_get_identifier_from_object_mods($last_good_object);

        if (!$last_good_record_id) {
            return FALSE;
        }

        // Get all the children objects' mets records.
        $image_array = ucla_migration_get_all_children_xmls($mets_xml);

        if (!$image_array) {
            return FALSE;
        }

        // Cycle through until you find the last successfully ingested object.
        $found = FALSE;
        $i = 0;
        for ($i; $i < count($image_array) && !$found; $i++) {
            $image_array_id = $image_array[$i]->attributes()->DMDID;
            if ($image_array[$i]->attributes()->DMDID == "DMD-$last_good_record_id") {
                $found = TRUE;
            }
        }

        // Start one record after the last successfully ingested object.
        $ingest_success = TRUE;
        for ($i; $i < count($image_array) && $ingest_success; $i++) {
            $ingest_success = ucla_migration_migrate_child_object($fedora_namespace, $image_array[$i], $mets_xml, $collection);
            if ($ingest_success) {
                watchdog('UCLA Migration', 'Migrated object @idx / @total', array(
                    '@idx' => $i + 1,
                    '@total' => count($image_array)
                ), WATCHDOG_INFO);
            }
        }

        // Exit if ingest of any child object failed.
        if (!$ingest_success) {
            watchdog('UCLA Migration', 'Child object ingest failed.', array(), WATCHDOG_ERROR);
            return FALSE;
        }

        return TRUE;
    }

    /**
     * Gets all of the TYPE='Image' divs from the mets xml.
     *
     * Each record in the results corresponds to a child object in the collection
     * that is being migrated.
     *
     * @param SimpleXMLElement $mets_xml
     *   The SimpleXMLElement representing the root node of the mets file.
     *
     * @return array
     *   All divs corresponding to children objects of the collection being
     *   migrated.  Returns FALSE if there's an error.
     */
    function ucla_migration_get_all_children_xmls($mets_xml) {
        // Query for each of the tiff files.
        // Each one will correspond to a child of the recently created collection.
        $image_query = "//mets:div[@TYPE='Image']";
        $image_array = $mets_xml->xpath($image_query);

        // Validate results.
        if (!is_array($image_array)) {
            watchdog('UCLA Migration', "Error in XPath query @query", array('@query' => $image_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (empty($image_array)) {
            watchdog('UCLA Migration', "No results for XPath query @query", array('@query' => $image_query), WATCHDOG_ERROR);
            return FALSE;
        }

        return $image_array;
    }

    /**
     * Grabs the record identifier from an object's MODS datastream.
     *
     * @param NewFedoraObject $object
     *   The objects whose record identifier you are looking for.
     *
     * @return string
     *   The record identifier from this object's MODS.  Returns FALSE if there's
     *   an error.
     */
    function ucla_migration_get_identifier_from_object_mods($object) {
        // Exit early if there's no MODS datastream.
        if (!isset($object['MODS']) || empty($object['MODS'])) {
            watchdog('UCLA Migration', "No MODS for object @pid", array('@pid' => $object->id), WATCHDOG_ERROR);
            return FALSE;
        }

        // Make a SimpleXMLElement for the MODS.
        $mods_txt = $object['MODS']->content;
        $mods = simplexml_load_string($mods_txt);

        // Register namespaces of the root element.
        $xml_namespaces = $mods->getDocNamespaces();
        $mods->registerXPathNamespace('mods', $xml_namespaces['mods']);

        // Query for the recordInfo div.
        $id_query = "//mods:mods/mods:recordInfo";
        $id_array = $mods->xpath($id_query);

        // Validate results.
        if (!is_array($id_array)) {
            watchdog('UCLA Migration', "Error in XPath query @query", array('@query' => $id_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (empty($id_array)) {
            watchdog('UCLA Migration', "No results for XPath query @query", array('@query' => $id_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (count($id_array) > 1) {
            watchdog('UCLA Migration', "More than one result for XPath query @query", array('@query' => $id_query), WATCHDOG_ERROR);
            return FALSE;
        }

        // Grab the children of the recordInfo div.  THERE CAN BE ONLY ONE!!!
        $children = $id_array[0]->children($xml_namespaces['mods']);

        if ($children->count() == 0) {
            watchdog('UCLA Migration', "The recordInfo div has no children.", array(), WATCHDOG_ERROR);
            return FALSE;
        }

        if ($children->count() > 1) {
            watchdog('UCLA Migration', "The recordInfo div has too many children.", array(), WATCHDOG_ERROR);
            return FALSE;
        }

        return $children->recordIdentifier;
    }

    /**
     * Migrates a child object of the collection object in the provided mets xml.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @param SimpleXMLElement $image_xml
     *   SimpleXML object that represents the mets div containing info about the
     *   tiff to migrate.
     *
     * @param SimpleXMLElement $mets_xml
     *   SimpleXML object that represents the mets file from the path provided to
     *   the drush script.
     *
     * @param NewFedoraObject $collection
     *   The collection this child will be a member of.
     *
     * @return NewFedoraObject
     *   The newly ingested child object.  Returns FALSE if there is an error
     *   at any point in the process.
     */
    function ucla_migration_migrate_child_object($fedora_namespace, $image_xml, $mets_xml, $collection) {
        $dmdid = $image_xml->attributes()->DMDID;
        $label = $image_xml->attributes()->LABEL;

        // Get the children elements of the collection section that have a mets
        // namespace.  This should correspond to a single mets:fptr element.
        $xml_namespaces = $mets_xml->getDocNamespaces();
        $fptr_section = $image_xml->children($xml_namespaces['mets']);

        // Validate.
        if ($fptr_section->count() == 0) {
            watchdog('UCLA Migration', "Could not locate fptr element for @id in the METS.", array('@id' => (string) $dmdid), WATCHDOG_ERROR);
            return FALSE;
        }

        if ($fptr_section->count() > 1) {
            watchdog('UCLA Migration', "Multiple fptr elements for @id in the METS.", array('@id' => (string) $dmdid), WATCHDOG_ERROR);
            return FALSE;
        }

        // Grab the file id from the ftpr element.
        $file_id = $fptr_section->attributes()->FILEID;

        // Use the file id to lookup the file path.
        $file_path_query = "//mets:file[@ID='$file_id']/mets:FLocat";
        $file_path_array = $mets_xml->xpath($file_path_query);

        // Validate.
        if (!is_array($file_path_array)) {
            watchdog('UCLA Migration', "Error in XPath query @query", array('@query' => $file_path_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (empty($file_path_array)) {
            watchdog('UCLA Migration', "No results for XPath query @query", array('@query' => $file_path_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (count($file_path_array) > 1) {
            watchdog('UCLA Migration', "More than one result for XPath query @query", array('@query' => $file_path_query), WATCHDOG_ERROR);
            return FALSE;
        }

        // Grab the file path from the XPath results.
        $file_path = $file_path_array[0]->attributes($xml_namespaces['xlink'])->href;

        // Use the DMDID to lookup the MODS record for this image.
        $mods_query = "//mets:dmdSec[@ID='$dmdid']/mets:mdWrap[@MDTYPE='MODS']/mets:xmlData";
        $mods_array = $mets_xml->xpath($mods_query);

        // Validate.
        if (!is_array($mods_array)) {
            watchdog('UCLA Migration', "Error in XPath query @query", array('@query' => $mods_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (empty($mods_array)) {
            watchdog('UCLA Migration', "No results for XPath query @query", array('@query' => $mods_query), WATCHDOG_ERROR);
            return FALSE;
        }

        if (count($mods_array) > 1) {
            watchdog('UCLA Migration', "More than one result for XPath query @query", array('@query' => $mods_query), WATCHDOG_ERROR);
            return FALSE;
        }

        // Attempt to to get the MODS element from the XPath results.
        $mods_element = $mods_array[0]->children('http://www.loc.gov/mods/v3');

        // Validate.
        if ($mods_element->count() == 0) {
            watchdog('UCLA Migration', "Could not locate mods element for @id in the METS.", array('@id' => (string) $dmdid), WATCHDOG_ERROR);
            return FALSE;
        }

        if ($mods_element->count() > 1) {
            watchdog('UCLA Migration', "Multiple mods elements for @id in the METS.", array('@id' => (string) $dmdid), WATCHDOG_ERROR);
            return FALSE;
        }

        // Grab the MODS record as a string.
        $mods_string = $mods_element->asXML();
        // Clean it up by adding the xsi namespace so SimpleXML and DOMDocument don't
        // cry every time something is done with the MODS.  The namespaces is in the
        // root node of the mets, but not the root node of the MODS.  So we'll just
        // add it in here for completeness.
        $mods_string = ucla_migration_add_xsi_namespace_to_mods_txt($mods_string);

        // Create the NewFedoraObject for this image.
        $child = ucla_migration_create_child_object($fedora_namespace, $label, $file_path, $mods_string, $collection);

        // Ingest the NewFedoraObject.
        $ingest_results = islandora_add_object($child);

        // Validate.
        if (!$ingest_results) {
            watchdog('UCLA Migration', "Ingest for the child object @id has failed.", array('@id' => (string) $dmdid), WATCHDOG_ERROR);
            return FALSE;
        }

        watchdog('UCLA Migration', 'Ingested @id as @pid', array(
            '@id' => (string) $dmdid,
            '@pid' => $ingest_results->id
        ), WATCHDOG_INFO);

        // Return the ingested object.
        return $ingest_results;
    }

    /**
     * Creates a NewFedoraObject for further processing and ingesting.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @param string $label
     *   The label to give the NewFedoraObject
     *
     * @return NewFedoraObject
     *   The newly created object.
     */
    function ucla_migration_create_fedora_object($fedora_namespace, $label) {
        global $user;
        $tuque = islandora_get_tuque_connection();
        $object = $tuque->repository->constructObject($fedora_namespace);
        $object->owner = isset($user->name) ? $user->name : $object->owner;
        $object->label = $label;
        return $object;
    }

    /**
     * Adds a MODS datastream to the supplied object from the supplied xml text.
     *
     * @param NewFedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $mods_txt
     *   A string of valid MODS text.
     */
    function ucla_migration_add_mods_to_object($object, $mods_txt) {
        $datastream = $object->constructDatastream('MODS', 'M');
        $datastream->label = "MODS Record";
        $datastream->mimetype = "text/xml";
        $datastream->setContentFromString($mods_txt);
        $object->ingestDatastream($datastream);
    }


    function ucla_migration_update_metadata_from_mods($object, $mods_txt, $old_metadata_value, $new_metadata_value, $local_name){
        try {
            $xslt_proc = new XSLTProcessor();

            $xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/update_metadata_value.xsl';
            $xslt_proc->setParameter('','old_value',$old_metadata_value);
            $xslt_proc->setParameter('','new_value',$new_metadata_value);
            $xslt_proc->setParameter('','update_element',$local_name);

            $xslt_dom = new DOMDocument();
            $xslt_dom->load($xslt_file);
            $xslt_proc->importStyleSheet($xslt_dom);

            // Prepare the mods DOM to transform.
            $mods_dom = new DOMDocument();
            $mods_dom->loadXML($mods_txt);

            // Transform the MODS to DC.
            $mods_new_txt = $xslt_proc->transformToXML($mods_dom);
            watchdog('UCLA Migration', "Mods Record is : @results", array('@results' => $mods_new_txt), WATCHDOG_NOTICE);
            //  update MODS record to the object as a datastream.
            /* if (isset($object['MODS'])) {
                 $datastream = $object['MODS'];
             } else {
                 $datastream = $object->constructDatastream('MODS','M');
                 $datastream->label = "MODS Record";
                 $datastream->mimetype = "text/xml";
             }*/
            $datastream = $object['MODS'];
            //$datastream->setContentFromString($mods_new_txt); This function did not update mods string
            $datastream->content = $mods_new_txt; // hence I used this attribute
            //$object->ingestDatastream($datastream);
        } catch (Exception $e) {

            watchdog('UCLA Migration', "Exception Trace is : @results", array('@results' => $e->getTraceAsString()), WATCHDOG_ERROR);
        }
    }

    function ucla_migration_delete_element_from_mods($object, $mods_txt, $element){
        try {
            $xslt_proc = new XSLTProcessor();


            if($element == "idep") {
                $xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/delete_extra_idep_program.xsl';
            } else {
                $xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/delete_element.xsl';
                $xslt_proc->setParameter('','removeElementsNamed',$element);
            }



            $xslt_dom = new DOMDocument();
            $xslt_dom->load($xslt_file);
            $xslt_proc->importStyleSheet($xslt_dom);

            // Prepare the mods DOM to transform.
            $mods_dom = new DOMDocument();
            $mods_dom->loadXML($mods_txt);

            // Transform the MODS to DC.
            $mods_new_txt = $xslt_proc->transformToXML($mods_dom);
            watchdog('UCLA Migration', "Mods Record is : @results", array('@results' => $mods_new_txt), WATCHDOG_NOTICE);
            //  update MODS record to the object as a datastream.
            /* if (isset($object['MODS'])) {
                 $datastream = $object['MODS'];
             } else {
                 $datastream = $object->constructDatastream('MODS','M');
                 $datastream->label = "MODS Record";
                 $datastream->mimetype = "text/xml";
             }*/
            $datastream = $object['MODS'];
            //$datastream->setContentFromString($mods_new_txt); This function did not update mods string
            $datastream->content = $mods_new_txt; // hence I used this attribute
            //$object->ingestDatastream($datastream);
        } catch (Exception $e) {

            watchdog('UCLA Migration', "Exception Trace is : @results", array('@results' => $e->getTraceAsString()), WATCHDOG_ERROR);
        }
    }

    function ucla_migration_add_genre_to_mods($object, $mods_txt, $metadata_value){
        try {
            $xslt_proc = new XSLTProcessor();
            if ($metadata_value == "video_recordings") {
                $xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/add_genre_mods_all_videos.xsl';
            } elseif ($metadata_value == "digital_moving_image_formats") {
                $xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/add_genre_mods_diaspora2.xsl';
            } else {
                $xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/add_genre_mods.xsl';
            }

            $xslt_dom = new DOMDocument();
            $xslt_dom->load($xslt_file);
            $xslt_proc->importStyleSheet($xslt_dom);

            // Prepare the mods DOM to transform.
            $mods_dom = new DOMDocument();
            $mods_dom->loadXML($mods_txt);

            // Transform the MODS to Mods with genre.
            $mods_new_txt = $xslt_proc->transformToXML($mods_dom);
            watchdog('UCLA Migration', "Mods Record is : @results", array('@results' => $mods_new_txt), WATCHDOG_NOTICE);
            // Add  or update Mods record to the object as a datastream.
            $is_new_mods_ds = FALSE;
            if (isset($object['MODS'])) {
                $datastream = $object['MODS'];
            } else {
                $datastream = $object->constructDatastream('MODS','M');
                $datastream->label = "MODS Record";
                $datastream->mimetype = "text/xml";
                $is_new_mods_ds = TRUE;
            }

            //$datastream->setContentFromString($mods_new_txt);
            $datastream->content = $mods_new_txt;
            if ($is_new_mods_ds) {
                $object->ingestDatastream($datastream);
            }
        } catch (Exception $e) {

            watchdog('UCLA Migration', "Exception Trace is : @results", array('@results' => $e->getTraceAsString()), WATCHDOG_ERROR);
        }
    }

    /*
     * This function is added to batch update the xslt to add the new mods element to support idep cross collection.
     */
    function ucla_migration_add_program_to_mods($object, $mods_txt){
        try {
            $xslt_proc = new XSLTProcessor();

             $xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/add_idep_program_mods.xsl';
            //$xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/add_collection_tahrir_mods.xsl';
            //$xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/add_type_to_collection_field.xsl';
            //$xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/add_date_issued_to_titles.xsl';
            //$xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/delete_dates_from_collection.xsl';
            $xslt_dom = new DOMDocument();
            $xslt_dom->load($xslt_file);
            $xslt_proc->importStyleSheet($xslt_dom);

            // Prepare the mods DOM to transform.
            $mods_dom = new DOMDocument();
            $mods_dom->loadXML($mods_txt);

            // Transform the MODS to add program name.
            $mods_new_txt = $xslt_proc->transformToXML($mods_dom);
            watchdog('UCLA Migration', "Mods Record is : @results", array('@results' => $mods_new_txt), WATCHDOG_NOTICE);
            // Add  or update Mods record to the object as a datastream.
            $is_new_mods_ds = FALSE;
            if (isset($object['MODS'])) {
                $datastream = $object['MODS'];
            } else {
                $datastream = $object->constructDatastream('MODS','M');
                $datastream->label = "MODS Record";
                $datastream->mimetype = "text/xml";
                $is_new_mods_ds = TRUE;
            }

            //$datastream->setContentFromString($mods_new_txt);
            $datastream->content = $mods_new_txt;
            if ($is_new_mods_ds) {
                $object->ingestDatastream($datastream);
            }
        } catch (Exception $e) {

            watchdog('UCLA Migration', "Exception Trace is : @results", array('@results' => $e->getTraceAsString()), WATCHDOG_ERROR);
        }
    }
    /**
     * Adds a DC datastream to the supplied object from the supplied MODS text.
     *
     * @param NewFedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $mods_txt
     *   A string of valid MODS text.
     */
    function ucla_migration_add_dc_to_object_from_mods($object, $mods_txt) {
        // Prepare the MODS to DC transform.
        try {
            $xslt_proc = new XSLTProcessor();
            $xslt_file = drupal_get_path('module', 'ucla_migration') . '/transforms/mods_to_dc.xsl';
            $xslt_dom = new DOMDocument();
            $xslt_dom->load($xslt_file);
            $xslt_proc->importStyleSheet($xslt_dom);

            // Prepare the mods DOM to transform.
            $mods_dom = new DOMDocument();
            $mods_dom->loadXML($mods_txt);

            // Transform the MODS to DC.
            $dc_txt = $xslt_proc->transformToXML($mods_dom);
            watchdog('UCLA Migration', "DC Record is : @results", array('@results' => $dc_txt), WATCHDOG_NOTICE);
            // Add  or update DC record to the object as a datastream.
            $is_new_mods_ds = FALSE;
            if (isset($object['DC'])) {
                $datastream = $object['DC'];
            } else {
                $datastream = $object->constructDatastream('DC');
                $datastream->label = "Dublin Core Record";
                $datastream->mimetype = "text/xml";
                $is_new_mods_ds = TRUE;
            }

            //$datastream->setContentFromString($dc_txt);
            $datastream->content = $dc_txt;
            if ($is_new_mods_ds) {
                $object->ingestDatastream($datastream);
            }
        } catch (Exception $e) {

            watchdog('UCLA Migration', "Exception Trace is : @results", array('@results' => $e->getTraceAsString()), WATCHDOG_ERROR);
        }
    }

    /**
     * Adds a namespace to the MODS text so SimpleXML won't cry.
     *
     * @param string $mods_txt
     *   Valid string of XML MODS that requires the extra namespace.
     *
     * @return string
     *   The patched up MODS text.
     */
    function ucla_migration_add_xsi_namespace_to_mods_txt($mods_txt) {
        return str_replace("xmlns:mods=\"http://www.loc.gov/mods/v3\"", "xmlns:mods=\"http://www.loc.gov/mods/v3\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"", $mods_txt);
    }

    /**
     * Adds a tiff (from path) to the supplied object as the OBJ datastream.
     *
     * @param NewFedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $tiff_path
     *   Valid path to a tiff file.
     */
    function ucla_migration_add_tiff_to_object($object, $tiff_path) {
        $datastream = $object->constructDatastream('OBJ', 'M');
        $datastream->label = "High Quality Tiff";
        $datastream->mimetype = "image/tiff";
        $datastream->setContentFromFile($tiff_path);
        $object->ingestDatastream($datastream);
    }

    /**
     * Creates the collection object for this migration.
     *
     * Adds relationships and content models for the collection, as well as a MODS
     * datastream.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @param string $label
     *   The label to give the NewFedoraObject
     *
     * @param string $mods_txt
     *   A string of valid MODS text.
     *
     * @return NewFedoraObject
     *   The fully constructed and setup collection object.
     */
    function ucla_migration_create_collection_object($fedora_namespace, $label, $mods_txt) {
        $collection = ucla_migration_create_fedora_object($fedora_namespace, $label);
        $collection->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:collectionCModel');
        $collection->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', 'islandora:root');
        ucla_migration_add_mods_to_object($collection, $mods_txt);
        ucla_Migration_add_dc_to_object_from_mods($collection, $mods_txt);
        return $collection;
    }

    /**
     * Creates a child object for the collection in this migration.
     *
     * Adds relationships and content models for the child, as well as MODS and OBJ
     * datastreams.
     *
     * @param string $fedora_namespace
     *   The Fedora namespace to ingest everything under.
     *
     * @param string $label
     *   The label to give the NewFedoraObject
     *
     * @param string $tiff_path
     *   Path to a high-res tiff for the OBJ datastream.
     *
     * @param string $mods_txt
     *   A string of valid MODS text.
     *
     * @param NewFedoraObject $collection
     *   The collection this child will be a member of.
     *
     * @return NewFedoraObject
     *   The fully constructed and setup collection object.
     */
    function ucla_migration_create_child_object($fedora_namespace, $label, $tiff_path, $mods_txt, $collection) {
        $child = ucla_migration_create_fedora_object($fedora_namespace, $label);
        $child->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:sp_large_image_cmodel');
        $child->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $collection->id);
        ucla_migration_add_mods_to_object($child, $mods_txt);
        ucla_Migration_add_dc_to_object_from_mods($child, $mods_txt);
        ucla_migration_add_tiff_to_object($child, $tiff_path);
        return $child;
    }

    function ucla_migration_create_id_to_pid_map($fedora_namespace, $datastream_id, $xpath_query) {
        $remote_id_to_fedora_pid = array();
        $pids = ucla_migration_get_pids_for_namespace($fedora_namespace);

        foreach ($pids as $pid) {
            $query_result = ucla_migration_get_value_from_datastream($pid, $datastream_id, $xpath_query);
            if ($query_result) {
                $identifier = $query_result[0];
                $remote_id_to_fedora_pid["$identifier"] = $pid;
            }
        }

        return $remote_id_to_fedora_pid;
    }

    function ucla_migration_get_value_from_datastream($pid, $datastream_id, $xpath_query) {
        $object = islandora_object_load($pid);
        if ($object[$datastream_id]) {

            libxml_use_internal_errors(TRUE);

            $xml_txt = $object[$datastream_id]->content;
            $xml_obj = simplexml_load_string($xml_txt);

            if (!$xml_obj !== FALSE) {
                $xml_namespaces = $xml_obj->getDocNamespaces();
                $xml_obj->registerXPathNamespace('mods', $xml_namespaces['mods']);
                $xpath_results = $xml_obj->xpath($xpath_query);
                return $xpath_results;
            } else {
                foreach (libxml_get_errors() as $error) {
                    drush_print('ERROR XML PARSE for pid ' . $pid . ' Message:' . $error->message);
                }
            }

            libxml_clear_errors();
            //return $xpath_results;
        }
    }

    /**
     *
     * Updates a specific datastream rather than importing all digital assets
     * associated with an item. This particular use case updates a TRANSLATION
     * datastream source
     *
     *
     * @param type $mets_file_path
     *  The path to the METS file containing both asset and metadata. This can be a
     *  remote url or a local file
     *
     * @param type $datastream_path
     * The path to the root folder of the datastreams to be updated, translation
     * files
     *
     * @param type $fedora_namespace
     *  The Fedora Namespace you want to update the datastream for. Example:
     *  Supplying com.example.namespace, will examine each item in this namespace
     *  and look for a related datastream to attach
     *
     * @return type
     *
     */
    function ucla_migration_migrate_datastream($mets_file_path, $datastream_path, $fedora_namespace) {


    // Check to make sure the path to the mets file has been provided.
        if (!isset($mets_file_path)) {
            drush_set_error('File path not provided', 'Path to mets file not provided as command line argument', 'Error: ');
            return;
        }

        // Attempt to grab the mets file.
        $mets_file = file_get_contents($mets_file_path);
        if (!$mets_file) {
            drush_set_error('File not found', "Could not locate mets file $mets_file_path", "Error: ");
            return;
        }

        $datastream_to_update = 'MODS';
        $xpath_query = '//mods:mods/mods:recordInfo/mods:recordIdentifier';
        $pid_map = ucla_migration_create_id_to_pid_map($fedora_namespace, $datastream_to_update, $xpath_query);


        $mets_xml = ucla_migration_mets_file_to_xml_object($mets_file);
        $mods_query = "//mets:dmdSec/mets:mdWrap/mets:xmlData";
        $mods_array = $mets_xml->xpath($mods_query);

        // For each MODS record:
        // - Extract resourceIdentifier (the ark)
        // - Compare ark to the pid-ark map, to get the pid of related Fedora object
        // - With the correct pid we can now update the datastream

        for ($i = 0; $i < sizeof($mods_array); $i++) {
            if (ucla_evaluate_mods_record_to_ingest($mods_array[$i], $pid_map)) {
                $ark_id = ucla_migration_get_ark_id_from_mods($mods_array[$i]);
                $fedora_pid = $pid_map[$ark_id];

                // The translation files have been named with 2nd half of ark
                $file_root = substr($ark_id, strrpos($ark_id, '-') + 1);
                $translation_filename = $datastream_path . '/' . $file_root . '.txt';

                $translation_file = @file_get_contents($translation_filename);

                if ($translation_file) {
                    $translation_file = mb_convert_encoding($translation_file, "UTF-8");
                    ucla_migration_add_datastream_to_object($fedora_pid, "TRANSLATION-EN", "text/plain", $translation_file);
                }
            }
        }
    }

    function ucla_migration_get_ark_id_from_mods($mods_simple_xml) {

        $mods_record = $mods_simple_xml->children('http://www.loc.gov/mods/v3');
        $mods_string = $mods_record->asXML();
        $mods_string = ucla_migration_add_xsi_namespace_to_mods_txt($mods_string);
        $mods_object = simplexml_load_string($mods_string);

        $id_query = "//mods:mods/mods:recordInfo";
        $id_array = $mods_object->xpath($id_query);
        $children = $id_array[0]->children('http://www.loc.gov/mods/v3');

        $ark_identifier = (string) $children->recordIdentifier;

        return $ark_identifier;
    }

    function ucla_evaluate_mods_record_to_ingest($mods_simple_xml, $pid_ark_map) {
        $ark_identifier = ucla_migration_get_ark_id_from_mods($mods_simple_xml);
        if (array_key_exists($ark_identifier, $pid_ark_map)) {
            return TRUE;
        }

        return FALSE;
    }

    function ucla_migration_get_pids_for_namespace($fedora_namespace) {
        // Get a connection to Fedora.
        $connection = islandora_get_tuque_connection();
        $repo = $connection->repository;

        // SPARQL query to get all objects in a given namespace.
        $query = "
        SELECT ?obj
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:'))
        }
      ";

        // Execute the query.
        $results = $repo->ri->sparqlQuery($query);

        // Put all the pids in an array.
        $pids = array();
        foreach ($results as $result) {
            array_push($pids, $result['obj']['value']);
        }

        return $pids;
    }

    function ucla_migration_mets_file_to_xml_object($mets_file) {
        $mets_xml = simplexml_load_string($mets_file);

        // Register namespaces of the root element.
        $xml_namespaces = $mets_xml->getDocNamespaces();
        $mets_xml->registerXPathNamespace('mets', $xml_namespaces['mets']);
        $mets_xml->registerXPathNamespace('xlink', $xml_namespaces['xlink']);

        return $mets_xml;
    }

    function ucla_migration_add_datastream_to_object($fedora_pid, $datastream_id, $mime_type, $datastream_content, $content_from_file = 0) {
        $fedora_object = islandora_object_load($fedora_pid);

        if (!is_null($fedora_object)) {
            $fedora_object->purgeDatastream("$datastream_id");

            $datastream = $fedora_object->constructDatastream($datastream_id, 'M');
            $datastream->label = "$datastream_id";
            $datastream->mimetype = "$mime_type";

            if ($content_from_file != 0) {
                $datastream->setContentFromFile($datastream_content);
            } else {
                $datastream->setContentFromString($datastream_content);
            }

            $fedora_object->ingestDatastream($datastream);
        }
    }

    /**
     *
     * Updates a specific datastream rather than importing all digital assets
     * associated with an item. The entries in the $datastream_path file should
     * contain a path to the digital asset to add. This filename will contain the
     * item ark, which is used to match the digital asset to the Fedora object to
     * add the content to.
     *
     *
     * @param type $datastream_path
     *  The path to the plain text file containing a path to the digital asset to be
     *  loaded. One path per line.
     *
     * @param type $datastream_id
     * The datastream Id to attach to this content when adding to the Fedora object,
     * this will also be used for the label value.
     *
     * @param type $mime_type
     * This is the mime type to attach to the data stream
     *
     * @param type $fedora_namespace
     *  The Fedora Namespace you want to update the datastream for. Example:
     *  Supplying com.example.namespace, will examine each item in this namespace
     *  and look for a related datastream to attach
     *
     * @return type
     *
     */
    function ucla_migration_attach_datastream($datastream_path, $datastream_id, $mime_type, $fedora_namespace) {

        if (!isset($datastream_path)) {
            drush_set_error('File path not provided', 'A path to the file containing the assets to load must be added', 'Error: ');
            return;
        }

        if (!isset($datastream_id)) {
            drush_set_error('Datastream Id not provided', 'A datastream id to apply to the asset is required', 'Error: ');
            return;
        }

        if (!isset($mime_type)) {
            drush_set_error('Mime type not provided', 'A Mime type for this added asset is required', 'Error: ');
            return;
        }

        if (!isset($fedora_namespace)) {
            drush_set_error('Namespace not provided', 'A namespace to match the assets to is required', 'Error: ');
            return;
        }


        // Attempt to grab the file containing list of content locations
        $datastream_asset_file = file($datastream_path, FILE_IGNORE_NEW_LINES);

        if (!$datastream_asset_file) {
            drush_set_error('File not found', "Could not locate mets file $datastream_path", "Error: ");
            return;
        }

        // Use the MODS datastream with a pointer to the recordIdentifer as the source
        // to generate the ark to pid mapping

        $datastream_containing_id = 'MODS';
        $xpath_query = '//mods:mods/mods:recordInfo/mods:recordIdentifier';
        $pid_map = ucla_migration_create_id_to_pid_map($fedora_namespace, $datastream_containing_id, $xpath_query);

        for ($i = 0; $i < sizeof($datastream_asset_file); $i++) {

            $file_to_get = chop($datastream_asset_file[$i]);
            $remote_ark = ucla_migration_get_ark_from_filename($file_to_get);
            $fedora_pid = $pid_map[$remote_ark];

            if (isset($fedora_pid)) {
                $file_to_attach = file_get_contents($file_to_get);

                if ($file_to_attach) {
                    ucla_migration_add_datastream_to_object($fedora_pid, $datastream_id, $mime_type, $file_to_get, 1);

                    $fedora_object = islandora_object_load($fedora_pid);
                    if (!is_null($fedora_object)) {

                        // Should abstract this out somehow for the user, all derivative ds
                        // must be removed before re-generated. If not removed, the function
                        // does NOT overwrite the datastreams

                        $fedora_object->purgeDatastream("TN");
                        $fedora_object->purgeDatastream("PREVIEW");

                        islandora_pdf_islandora_sp_pdf_islandora_object_ingested($fedora_object);
                    }
                }
            }
        }
    }

    function ucla_migration_get_ark_from_filename($filename) {
        $ucla_naan = "21198";

        // Extract ark from filename, assuming naming convention of DLCS
        $ark_start_pos = strpos($filename, $ucla_naan);
        $ucla_naan_end_pos = $ark_start_pos + 6;
        $ark_end_pos = strpos($filename, "-", $ucla_naan_end_pos);
        $ark_value = substr($filename, $ark_start_pos, $ark_end_pos - $ark_start_pos);

        return $ark_value;
    }

    /**
     *
     *  Given Datastream ID, namespace, and range of numbers, delete the datastream
     * `from these Fedora objects
     *  Example input: DS_TO_DELETE, my.object.namespace, 1,2-5,10-12
     *  Return array: 1,2,3,4,5,10,11,12
     *
     *  The options are not passed as function parameters, but rather as drush
     *  command line options
     *
     * @param type $datastream_id
     *  The datastream id of the dsid you wish to delete from the objects
     *
     * @param type $fedora_namespace
     *  The namespace base that will be used, along with the number range, to
     *  generate the pids to remove
     *
     * @param type $pid_numbers
     *  A string containing single numeric values and ranges of values, separated
     *  by a comma. Ranges are designated by a dash '-'
     *
     *
     * @return type
     *
     */
    function ucla_migration_delete_datastream() {

        $dsid = drush_get_option('datastream_id');
        $fedora_namespace = drush_get_option('fedora_namespace');
        $pid_range = drush_get_option('pid_numbers');

        $parse_pids = _parse_number_range($pid_range);
        $delete_count = 0;

        foreach ($parse_pids as $parse_pid) {
            $full_name = $fedora_namespace . ":" . $parse_pid;
            $fedora_object = islandora_object_load($full_name);

            if ($fedora_object) {
                $result_code = $fedora_object->purgeDatastream($dsid);
                $result_text = 'Failure';

                if ($result_code == 1) {
                    $result_text = 'Success';
                    $delete_count++;
                }
                drush_log("Delete {$dsid} datastream from {$full_name} - Result : {$result_text}", 'ok');
            }
        }
        drush_log("Deleted {$dsid} from {$delete_count} total objects", 'ok');
    }

    /**
     *
     *  Given a string value representing ranges and single numbers, extracts and
     *  converts the input into a single array containing unique values.
     *  Example input: 1,2-5,10-12
     *  Return array: 1,2,3,4,5,10,11,12
     *
     *
     * @param type $range_values
     *  A string containing single numeric values and ranges of values, separated
     *  by a comma. Ranges are designated by a dash '-'
     *
     *
     * @return type $pid_numbers
     *  An array containing a unique list of values extracted from the input range
     *
     */
    function _parse_number_range($range_values) {

        $number_chunks = split(",", $range_values);
        $pid_numbers = array();

        foreach ($number_chunks as $number_chunk) {
            $range_value = split("-", $number_chunk);

            if (sizeof($range_value) == 1) {
                if (is_numeric($range_value[0])) {
                    array_push($pid_numbers, $range_value[0]);
                }
            }

            if (sizeof($range_value) == 2) {
                if (is_numeric($range_value[0]) && is_numeric($range_value[1])) {
                    foreach (range($range_value[0], $range_value[1]) as $val) {
                        array_push($pid_numbers, $val);
                    }
                }
            }
        }
        $pid_numbers = array_unique($pid_numbers);

        return $pid_numbers;
    }

    /**
     *
     *  A function to provide minimum metadata data for ingest of large numbers of
     *  assets. Content type will be assumed based on the extension
     *
     *  TIF - Will use a large image content model
     *  PDF - Will use the basic PDF content model
     *  XML - MODS XML
     *  MP4 - Will use video content model
     *
     *  The metadata attached to the content will be a MODS record containing the
     *  following values
     *
     *  title : The filename of the file ingested
     *  identifier : The filename of the file ingested
     *
     *  Both these values will be crosswalked to DC and available via triplestore
     *  query
     *
     * @param type $fedora_namespace
     *  The namespace in Fedora to relate as the collection parent for the minimal
     *  import
     *
     * @param type $manifest_file_path
     *  A path to a file containing a file path to a single asset on each line
     *
     * @param type $overwrite
     *  If true, remove existing Fedora objects in this namespace with the same
     * filename
     *
     *
     */
    function images_ingest_with_mods() {

        $fedora_namespace = drush_get_option('fedora_namespace');
        $manifest_file_path = drush_get_option('manifest_file_path');
        $overwrite = drush_get_option('overwrite');


        $manifest_file = file($manifest_file_path, FILE_IGNORE_NEW_LINES);
        if (!$manifest_file) {
            drush_set_error('File not found', "Could not locate manifest file file $manifest_file_path", "Error: ");
            return;
        }

        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }

        if (!isset($overwrite)) {
            drush_set_error('Overwrite flag not specified', '', 'Error: ');
            return;
        }


        $collection = islandora_object_load($fedora_namespace . ':1');


        foreach ($manifest_file as $file_path) {


            $file_path = trim($file_path);


            if (_is_valid_extension($file_path)) {


                $file_path = _url_encode_http_address($file_path);

                if (fopen($file_path, "r")) {


                    $file_name = basename($file_path);

                    $fedora_object = ucla_migration_create_fedora_object($fedora_namespace, $file_name);


                    $fedora_object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $collection->id);

                    //First time use this method to add the digital object
                    _add_datastream_images_and_mods_to_object($fedora_object, $file_path, FALSE);

                    //second time use this method to add the mods xml.
                    _add_datastream_images_and_mods_to_object($fedora_object, $file_path, TRUE);


                    $ingest_results = islandora_add_object($fedora_object);


                    watchdog('Ingest Success', 'Migrated object @file_name', array('@file_name' => $file_name), WATCHDOG_INFO);
                } else {
                    watchdog('Ingest Error', 'Child object ingest failed.', array(), WATCHDOG_ERROR);
                }
            }
        }
    }

    /**
     *
     *  A function to provide minimum metadata data for ingest of large numbers of
     *  assets. Content type will be assumed based on the extension
     *
     *  TIF - Will use a large image content model
     *  PDF - Will use the basic PDF content model
     *  XML - MODS XML
     *  MP4 - Will use video content model
     *
     *  The metadata attached to the content will be a MODS record containing the
     *  following values
     *
     *  title : The filename of the file ingested
     *  identifier : The filename of the file ingested
     *
     *  Both these values will be crosswalked to DC and available via triplestore
     *  query
     *
     * @param type $fedora_namespace
     *  The namespace in Fedora to relate as the collection parent for the minimal
     *  import
     *
     * @param type $manifest_file_path
     *  A path to a file containing a file path to a single asset on each line
     *
     * @param type $overwrite
     *  If true, remove existing Fedora objects in this namespace with the same
     * filename
     *
     *
     */
    function mp4_ingest_with_mods() {

        $fedora_namespace = drush_get_option('fedora_namespace');
        $manifest_file_path = drush_get_option('manifest_file_path');
        $overwrite = drush_get_option('overwrite');


        $manifest_file = file($manifest_file_path, FILE_IGNORE_NEW_LINES);
        if (!$manifest_file) {
            drush_set_error('File not found', "Could not locate manifest file file $manifest_file_path", "Error: ");
            return;
        }

        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }

        if (!isset($overwrite)) {
            drush_set_error('Overwrite flag not specified', '', 'Error: ');
            return;
        }


        $collection = islandora_object_load($fedora_namespace . ':1');


        foreach ($manifest_file as $file_path) {


            $file_path = trim($file_path);


            if (_is_valid_extension($file_path)) {


                $file_path = _url_encode_http_address($file_path);

                if (fopen($file_path, "r")) {


                    $file_name = basename($file_path);

                    $fedora_object = ucla_migration_create_fedora_object($fedora_namespace, $file_name);


                    $fedora_object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $collection->id);

                    //First time use this method to add the digital object
                    _add_datastream_mp4_and_mods_to_object($fedora_object, $file_path, TRUE);

                    //second time use this method to add the mods xml.
                    _add_datastream_mp4_and_mods_to_object($fedora_object, $file_path, FALSE);


                    $ingest_results = islandora_add_object($fedora_object);


                    watchdog('Ingest Success', 'Migrated object @file_name', array('@file_name' => $file_name), WATCHDOG_INFO);
                } else {
                    watchdog('Ingest Error', 'Child object ingest failed.', array(), WATCHDOG_ERROR);
                }
            }
        }
    }

    /**
     *
     *  A function to provide minimum metadata data for ingest of large numbers of
     *  assets. Content type will be assumed based on the extension
     *
     *  TIF - Will use a large image content model
     *  PDF - Will use the basic PDF content model
     *
     *  The metadata attached to the content will be a MODS record containing the
     *  following values
     *
     *  title : The filename of the file ingested
     *  identifier : The filename of the file ingested
     *
     *  Both these values will be crosswalked to DC and available via triplestore
     *  query
     *
     * @param type $fedora_namespace
     *  The namespace in Fedora to relate as the collection parent for the minimal
     *  import
     *
     * @param type $manifest_file_path
     *  A path to a file containing a file path to a single asset on each line
     *
     * @param type $overwrite
     *  If true, remove existing Fedora objects in this namespace with the same
     * filename
     *
     *
     */
    function minimum_metadata_ingest() {
        $time_start = microtime(true);
        $fedora_namespace = drush_get_option('fedora_namespace');
        $manifest_file_path = drush_get_option('manifest_file_path');
        $overwrite = drush_get_option('overwrite');
        $digitalObject = drush_get_option('digitalObject');


        $manifest_file = file($manifest_file_path, FILE_IGNORE_NEW_LINES);
        if (!$manifest_file) {
            drush_set_error('File not found', "Could not locate manifest file file $manifest_file_path", "Error: ");
            return;
        }

        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }

        if (!isset($overwrite)) {
            drush_set_error('Overwrite flag not specified', '', 'Error: ');
            return;
        }
        if (!isset($digitalObject)) {
            drush_set_error('Please specify one of the following for digitalObject (IMAGE , PDF, VIDEO, MODS, TN)  not specified', '', 'Error: ');
            return;
        }


        $collection = islandora_object_load($fedora_namespace . ':1');
        $tuque = islandora_get_tuque_connection();
        $repository = $tuque->repository;
        foreach ($manifest_file as $file_path) {

            $file_path = trim($file_path);

            if (_is_valid_extension($file_path)) {

                $file_path = _url_encode_http_address($file_path);

                if (fopen($file_path, "r")) {

                    $file_name = basename($file_path);
                    // SPARQL query to get all objects in a given namespace.
                    $query = "
                                SELECT ?obj ?label
                                FROM <#ri>
                                WHERE {
                                    ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
                                    ?obj <fedora-model:label> ?label .
                                    FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:')) .
                                    FILTER(regex(str(?label), '$file_name'))
                                }
                    ";

                    $total = $repository->ri->countQuery($query,'sparql');
                    if($total == 0){
                        $fedora_object = ucla_migration_create_fedora_object($fedora_namespace, $file_name);
                        $fedora_object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $collection->id);


                        _add_datastream_to_object($fedora_object, $file_path, $digitalObject);
                        $ingest_results = islandora_add_object($fedora_object);


                        watchdog('Ingest Success', 'Migrated object @file_name', array('@file_name' => $file_name), WATCHDOG_INFO);
                    } else {
                        watchdog('Ingest Error', 'Duplicate object @file_path ', array('@file_path' => $file_path), WATCHDOG_ERROR);
                        file_put_contents('duplicateObjectFound'.date("Y-m-d").'.txt',$file_path, FILE_APPEND);
                    }

                } else {
                    watchdog('Ingest Error', 'Datastream ingest failed for @file_path ', array('@file_path' => $file_path), WATCHDOG_ERROR);
                    file_put_contents('CreateObjectFailed'.date("Y-m-d").'.txt',$file_path, FILE_APPEND);
                }
            }
        }

        $time_end = microtime(true);
        $time = $time_end - $time_start;
        watchdog('Ingest Time', 'Took @timecomplete seconds to finish the script', array('@timecomplete' => $time), WATCHDOG_NOTICE);

    }


    /* for IDEP collections , we need to share objects with multiple collections*/
    function share_objects_between_collection() {

        $fedora_namespace = drush_get_option('fedora_namespace');
        $manifest_file_path = drush_get_option('manifest_file_path');
        $overwrite = drush_get_option('overwrite');
        $digitalObject = drush_get_option('digitalObject');
        $sharedCollection = drush_get_option('sharedCollection');

        $manifest_file = file($manifest_file_path, FILE_IGNORE_NEW_LINES);
        if (!$manifest_file) {
            drush_set_error('File not found', "Could not locate manifest file file $manifest_file_path", "Error: ");
            return;
        }

        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }

        if (!isset($overwrite)) {
            drush_set_error('Overwrite flag not specified', '', 'Error: ');
            return;
        }
        if (!isset($digitalObject)) {
            drush_set_error('Please specify one of the following for digitalObject (IMAGE , PDF, VIDEO, MODS, TN)  not specified', '', 'Error: ');
            return;
        }

        if (!isset($sharedCollection)) {
            drush_set_error('comma separated collection pids required', '', 'Error: ');
            return;
        }


        $collection = islandora_object_load($fedora_namespace . ':1');
        $collectionPids = explode(',',$sharedCollection);
        foreach ($manifest_file as $file_path) {

            $file_path = trim($file_path);

            if (_is_valid_extension($file_path)) {

                $file_path = _url_encode_http_address($file_path);

                if (fopen($file_path, "r")) {

                    $file_name = basename($file_path);

                    $fedora_object = ucla_migration_create_fedora_object($fedora_namespace, $file_name);
                    $fedora_object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $collection->id);
                    foreach($collectionPids as $collectionPid){
                        $fedora_object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $collectionPid . ':1');
                    }


                    _add_datastream_to_object($fedora_object, $file_path, $digitalObject);
                    $ingest_results = islandora_add_object($fedora_object);


                    watchdog('Ingest Success', 'Migrated object @file_name', array('@file_name' => $file_name), WATCHDOG_INFO);
                } else {
                    watchdog('Ingest Error', 'Child object ingest failed.', array(), WATCHDOG_ERROR);
                }
            }
        }
    }




    function add_children_to_manuscript() {

        $fedora_namespace = drush_get_option('fedora_namespace');
        $manifest_file_path = drush_get_option('manifest_file_path');
        $digitalObject = drush_get_option('digitalObject');


        $manifest_file = file($manifest_file_path, FILE_IGNORE_NEW_LINES);
        if (!$manifest_file) {
            drush_set_error('File not found', "Could not locate manifest file file $manifest_file_path", "Error: ");
            return;
        }

        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }


        if (!isset($digitalObject)) {
            drush_set_error('Please specify one of the following for digitalObject (TIFF,JPEG , PDF, VIDEO, MODS)  not specified', '', 'Error: ');
            return;
        }


        // $collection = islandora_object_load($fedora_namespace . ':1');
        watchdog('UCLA Migration', "begin 1 @results", array('@results' => $fedora_namespace), WATCHDOG_NOTICE);
        $connection = islandora_get_tuque_connection();
        watchdog('UCLA Migration', "begin 2 @results", array('@results' => $connection), WATCHDOG_NOTICE);
        $repo = $connection->repository;
        watchdog('UCLA Migration', "begin 3 @results", array('@results' => $repo), WATCHDOG_NOTICE);
        foreach ($manifest_file as $file_path) {

            $file_path = trim($file_path);

            if (_is_valid_extension($file_path)) {

                $file_path = _url_encode_http_address($file_path);
                watchdog('Ingest started ', 'file path @file_name', array('@file_name' => $file_path), WATCHDOG_NOTICE);
                if (fopen($file_path, "r")) {

                    $file_name = basename($file_path);
                    $nameArray = explode("_", $file_name);
                    $searchString = substr($file_name, 0, strlen($file_name) - 9);
                    $searchString = $nameArray[0] . '_' . $nameArray[1] . "_MODS.xml";
                    $sequenceString = str_replace('.tif', '', $nameArray[2]);
                    $sequence = intval($sequenceString);
                    watchdog('Ingest started ', 'search string @file_name', array('@file_name' => $searchString), WATCHDOG_NOTICE);

                    // SPARQL query to parent object in a given namespace.
                    $query = "
        SELECT ?obj ?label
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
     ?obj <fedora-model:label> ?label .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:')) .
          FILTER(regex(str(?label), '^$searchString'))
        }
      ";

                    watchdog('UCLA Migration', "begin 4 @results", array('@results' => $query), WATCHDOG_NOTICE);
                    // Execute the query.
                    $results = $repo->ri->sparqlQuery($query);
                    watchdog('UCLA Migration', "begin 5 @results", array('@results' => $results), WATCHDOG_NOTICE);
                    $count = 0;
                    foreach ($results as $result) {
                        $count++;
                        $object = islandora_object_load($result['obj']['value']);
                        $object_content_models = $object->relationships->get('info:fedora/fedora-system:def/model#', 'hasModel');

                        $hasModelManuscriptCModel = FALSE;
                        foreach ($object_content_models as $model) {
                            watchdog('UCLA Migration', "has Model Object @results", array('@results' => $model), WATCHDOG_NOTICE);
                            if ($model['object']['value'] == 'islandora:manuscriptCModel') {
                                $hasModelManuscriptCModel = TRUE;
                                break;
                            }
                        }
                        if ($hasModelManuscriptCModel == FALSE) {
                            $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:manuscriptCModel');
                        }
                        // $pages = get_pages($object);
                        //$num_pages = count($pages) + 1;
                        $fedora_object = ucla_migration_create_fedora_object($fedora_namespace, $file_name);
                        $fedora_object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOf', $object->id);
                        $fedora_object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:manuscriptPageCModel');
                        $fedora_object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isPageOf', $object->id);
                        $fedora_object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isSequenceNumber', (string) $sequence);
                        $fedora_object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isPageNumber', (string) $sequence);
                        $fedora_object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isSection', '1');
                        watchdog('UCLA Migration', "PID @results", array('@results' => $object->id), WATCHDOG_NOTICE);
                        _add_datastream_to_object($fedora_object, $file_path, $digitalObject);
                        $ingest_results = islandora_add_object($fedora_object);
                        watchdog('Ingest Success', 'Migrated object @file_name => @ingest', array('@file_name' => $file_name, '@ingest' => $ingest_results), WATCHDOG_NOTICE);
                        if ($count == 1) {
                            break;
                        }
                    }
                } else {
                    watchdog('Ingest Error', 'Child object ingest failed.', array(), WATCHDOG_ERROR);
                }
            }
        }
    }

    function add_children_to_compound_object() {

        $fedora_namespace = drush_get_option('fedora_namespace');
        $manifest_file_path = drush_get_option('manifest_file_path');
        $digitalObject = drush_get_option('digitalObject');


        $manifest_file = file($manifest_file_path, FILE_IGNORE_NEW_LINES);
        if (!$manifest_file) {
            drush_set_error('File not found', "Could not locate manifest file file $manifest_file_path", "Error: ");
            return;
        }

        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }


        if (!isset($digitalObject)) {
            drush_set_error('Please specify one of the following for digitalObject (TIFF,JPEG , PDF, VIDEO, MODS)  not specified', '', 'Error: ');
            return;
        }


        // $collection = islandora_object_load($fedora_namespace . ':1');
        watchdog('UCLA Migration', "begin 1 @results", array('@results' => $fedora_namespace), WATCHDOG_NOTICE);
        $connection = islandora_get_tuque_connection();
        watchdog('UCLA Migration', "begin 2 @results", array('@results' => $connection), WATCHDOG_NOTICE);
        $repo = $connection->repository;
        watchdog('UCLA Migration', "begin 3 @results", array('@results' => $repo), WATCHDOG_NOTICE);
        foreach ($manifest_file as $file_path) {

            $file_path = trim($file_path);

            if (_is_valid_extension($file_path)) {

                $file_path = _url_encode_http_address($file_path);
                watchdog('Ingest started ', 'file path @file_name', array('@file_name' => $file_path), WATCHDOG_NOTICE);
                if (fopen($file_path, "r")) {

                    $file_name = basename($file_path);
                    $nameArray = explode("-", $file_name);
                    //$searchString = substr($file_name, 0, strlen($file_name) - 9);
                    $searchString = $nameArray[0] . '-' . "1.xml";
                    $sequenceString = str_replace('.tif', '', $nameArray[1]);
                    $sequence = intval($sequenceString);
                    watchdog('Ingest started ', 'search string @file_name', array('@file_name' => $searchString), WATCHDOG_NOTICE);

                    // SPARQL query to parent object in a given namespace.
                    $query = "
        SELECT ?obj ?label
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
     ?obj <fedora-model:label> ?label .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:')) .
          FILTER(regex(str(?label), '^$searchString'))
        }
      ";

                    watchdog('UCLA Migration', "begin 4 @results", array('@results' => $query), WATCHDOG_NOTICE);
                    // Execute the query.
                    $results = $repo->ri->sparqlQuery($query);
                    watchdog('UCLA Migration', "begin 5 @results", array('@results' => $results), WATCHDOG_NOTICE);
                    $count = 0;
                    foreach ($results as $result) {
                        $count++;
                        $object = islandora_object_load($result['obj']['value']);
                        $object_content_models = $object->relationships->get('info:fedora/fedora-system:def/model#', 'hasModel');

                        $hasModelManuscriptCModel = FALSE;
                        foreach ($object_content_models as $model) {
                            watchdog('UCLA Migration', "has Model Object @results", array('@results' => $model), WATCHDOG_NOTICE);
                            if ($model['object']['value'] == 'islandora:compoundCModel') {
                                $hasModelManuscriptCModel = TRUE;
                                break;
                            }
                        }
                        if ($hasModelManuscriptCModel == FALSE) {
                            $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:compoundCModel');
                        }
                        // $pages = get_pages($object);
                        //$num_pages = count($pages) + 1;
                        $fedora_object = ucla_migration_create_fedora_object($fedora_namespace, $file_name);
                        $fedora_object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $fedora_namespace.':1');
                        $fedora_object->relationships->add(FEDORA_RELS_EXT_URI, 'isConstituentOf', $object->id);
                        $escape_pid = str_replace(':', '_', $object->id);
                        // $fedora_object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:manuscriptPageCModel');
                        // $fedora_object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isPageOf', $object->id);
                        $fedora_object->relationships->add(ISLANDORA_RELS_EXT_URI, "isSequenceNumberOf$escape_pid", (string) $sequence, TRUE);
                        //$fedora_object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isPageNumber', (string) $sequence);
                        //$fedora_object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isSection', '1');
                        watchdog('UCLA Migration', "PID @results", array('@results' => $object->id), WATCHDOG_NOTICE);
                        _add_datastream_to_object($fedora_object, $file_path, $digitalObject);
                        $ingest_results = islandora_add_object($fedora_object);
                        watchdog('Ingest Success', 'Migrated object @file_name => @ingest', array('@file_name' => $file_name, '@ingest' => $ingest_results), WATCHDOG_NOTICE);
                        if ($count == 1) {
                            break;
                        }
                    }
                } else {
                    watchdog('Ingest Error', 'Child object ingest failed.', array(), WATCHDOG_ERROR);
                }
            }
        }
    }

    function get_pages(AbstractObject $object) {
        $query = <<<EOQ
    PREFIX islandora-rels-ext: <http://islandora.ca/ontology/relsext#>
    SELECT ?pid ?page ?label ?width ?height
    FROM <#ri>
    WHERE {
      ?pid <fedora-rels-ext:isMemberOf> <info:fedora/{$object->id}> ;
           <fedora-model:label> ?label ;
           islandora-rels-ext:isSequenceNumber ?page ;
           <fedora-model:state> <fedora-model:Active> .
      OPTIONAL {
        ?pid <fedora-view:disseminates> ?dss .
        ?dss <fedora-view:disseminationType> <info:fedora/*/JP2> ;
             islandora-rels-ext:width ?width ;
             islandora-rels-ext:height ?height .
     }
    }
    ORDER BY ?page
EOQ;

        $results = $object->repository->ri->sparqlQuery($query);

        // Get rid of the "extra" info...
        $map = function($o) {
            foreach ($o as $key => &$info) {
                $info = $info['value'];
            }

            $o = array_filter($o);

            return $o;
        };
        $pages = array_map($map, $results);

        // Grab the PIDs...
        $get_pid = function($o) {
            return $o['pid'];
        };
        $pids = array_map($get_pid, $pages);

        // If we have some pages, combine our remapped results to produce an array
        // mapping pids to the values for that pid.
        $pages = count($pids) ? array_combine($pids, $pages) : array();

        // Sort the pages into their proper order.
        $sort = function($a, $b) {
            $a = (is_array($a) && isset($a['page'])) ? $a['page'] : 0;
            $b = (is_array($b) && isset($b['page'])) ? $b['page'] : 0;
            if ($a == $b) {
                return 0;
            }
            return ($a < $b) ? -1 : 1;
        };
        uasort($pages, $sort);

        return $pages;
    }

    function fix_page_sequence_number() {
        $fedora_namespace = drush_get_option('fedora_namespace');
        $manifest_file_path = drush_get_option('manifest_file_path');



        $manifest_file = file($manifest_file_path, FILE_IGNORE_NEW_LINES);
        if (!$manifest_file) {
            drush_set_error('File not found', "Could not locate manifest file file $manifest_file_path", "Error: ");
            return;
        }

        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }





        // $collection = islandora_object_load($fedora_namespace . ':1');
        watchdog('UCLA Migration', "begin 1 @results", array('@results' => $fedora_namespace), WATCHDOG_NOTICE);
        $connection = islandora_get_tuque_connection();
        watchdog('UCLA Migration', "begin 2 @results", array('@results' => $connection), WATCHDOG_NOTICE);
        $repo = $connection->repository;
        watchdog('UCLA Migration', "begin 3 @results", array('@results' => $repo), WATCHDOG_NOTICE);
        foreach ($manifest_file as $file_path) {

            $file_path = trim($file_path);
            if (_is_valid_extension($file_path)) {

                $file_path = _url_encode_http_address($file_path);
                watchdog('Ingest started ', 'file path @file_name', array('@file_name' => $file_path), WATCHDOG_NOTICE);
                if (fopen($file_path, "r")) {

                    $file_name = basename($file_path);
                    $nameArray = explode("_", $file_name);
                    $sequenceString = str_replace('.tif', '', $nameArray[2]);
                    $sequence = intval($sequenceString);
                    watchdog('Ingest started ', 'search string @file_name', array('@file_name' => $file_name), WATCHDOG_NOTICE);

                    // SPARQL query to parent object in a given namespace.
                    $query = "
        SELECT ?obj ?label
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
     ?obj <fedora-model:label> ?label .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:')) .
          FILTER(regex(str(?label), '^$file_name'))
        }
      ";

                    watchdog('UCLA Migration', "begin 4 @results", array('@results' => $query), WATCHDOG_NOTICE);
                    // Execute the query.
                    $results = $repo->ri->sparqlQuery($query);
                    watchdog('UCLA Migration', "begin 5 @results", array('@results' => $results), WATCHDOG_NOTICE);
                    foreach ($results as $result) {
                        $object = islandora_object_load($result['obj']['value']);
                        $object->relationships->remove(ISLANDORA_RELS_EXT_URI, 'isSequenceNumber');
                        $object->relationships->remove(ISLANDORA_RELS_EXT_URI, 'isPageNumber');
                        $object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isSequenceNumber', (string) $sequence);
                        $object->relationships->add(ISLANDORA_RELS_EXT_URI, 'isPageNumber', (string) $sequence);
                    }
                }
            }
        }
    }

    function delete_fedoraObject_by_nameSpace($fedora_namespace) {
        //$fedora_namespace = drush_get_option('fedora_namespace');
        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }
        // Get a connection to Fedora.
        $connection = islandora_get_tuque_connection();
        watchdog('Delete step 1 connection object', ' @file_name', array('@file_name' => $connection), WATCHDOG_NOTICE);
        $repo = $connection->repository;
        watchdog('Delete step 2 connection object', ' @file_name', array('@file_name' => $repo), WATCHDOG_NOTICE);

        // SPARQL query to get all objects in a given namespace.
        $query = "
        SELECT ?obj
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:'))
        }
      ";
        watchdog('Delete step 3 connection object', ' @file_name', array('@file_name' => $query), WATCHDOG_NOTICE);
        // Execute the query.
        $results = $repo->ri->sparqlQuery($query);

        watchdog('Delete step 4 connection object', ' @file_name', array('@file_name' => var_dump($results)), WATCHDOG_NOTICE);
        $pids = array();
        foreach ($results as $result) {
            watchdog('Delete step 4 in foreach', ' @file_name', array('@file_name' => var_dump($result)), WATCHDOG_NOTICE);
            if ($result['obj']['value'] !== $fedora_namespace . ':1') {
                array_push($pids, $result['obj']['value']);
            }
        }
        if($pids){
            _purge_object_by_pid($pids);
        }

    }

    function delete_fedoraObject_by_pids($pids) {

        if (!isset($pids)) {
            drush_set_error('Pids not provided', 'A pids to associate with the ingest must be provided', 'Error: ');
            return;
        }


        $pids_file = file($pids, FILE_IGNORE_NEW_LINES);
        if (!$pids_file) {
            drush_set_error('File not found', "Could not locate manifest file $pids", "Error: ");
            return;
        }

        _purge_object_by_pid($pids_file);
    }

    function delete_fedoraObject_by_nameSpace_searchQuery($fedora_namespace,$label_search) {
        //$fedora_namespace = drush_get_option('fedora_namespace');
        //$label_search  = drush_get_option('label_search');
        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }

        if (!isset($label_search)) {
            drush_set_error('Search label not provided', 'Search query needed', 'Error: ');
            return;
        }
        // Get a connection to Fedora.
        $connection = islandora_get_tuque_connection();
        watchdog('Delete step 1 connection object', ' @file_name', array('@file_name' => $connection), WATCHDOG_NOTICE);
        $repo = $connection->repository;
        watchdog('Delete step 2 connection object', ' @file_name', array('@file_name' => $repo), WATCHDOG_NOTICE);

        // SPARQL query to get all objects in a given namespace.
        $query = "
        SELECT ?obj ?label
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
          ?obj <fedora-model:label> ?label .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:')) .
         FILTER(regex(str(?label), '$label_search'))
        }
      ";
        watchdog('Delete step 3 connection object', ' @file_name', array('@file_name' => $query), WATCHDOG_NOTICE);
        // Execute the query.
        $results = $repo->ri->sparqlQuery($query);

        watchdog('Delete step 4 connection object', ' @file_name', array('@file_name' => var_dump($results)), WATCHDOG_NOTICE);
        $pids = array();
        foreach ($results as $result) {
            watchdog('Delete step 4 in foreach', ' @file_name', array('@file_name' => var_dump($result)), WATCHDOG_NOTICE);
            if ($result['obj']['value'] !== $fedora_namespace . ':1') {
                array_push($pids, $result['obj']['value']);
            }
        }
        _purge_object_by_pid($pids);
    }

    function add_dataStream_to_digitalObject() {
        $time_start = microtime(true);
        $fedora_namespace = drush_get_option('fedora_namespace');
        $manifest_file_path = drush_get_option('manifest_file_path');
        $digitalObject = drush_get_option('digitalObject');



        if (!isset($digitalObject)) {
            drush_set_error('Please specify one of the following for digitalObject (TIFF, JPEG, PDF, VIDEO, MODS, TEI, TN)  not specified', '', 'Error: ');
            return;
        }


        $manifest_file = file($manifest_file_path, FILE_IGNORE_NEW_LINES);
        if (!$manifest_file) {
            drush_set_error('File not found', "Could not locate manifest file file $manifest_file_path", "Error: ");
            return;
        }

        if (!isset($fedora_namespace)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }



        watchdog('UCLA Migration', "begin 1 @results", array('@results' => $fedora_namespace), WATCHDOG_NOTICE);
        $connection = islandora_get_tuque_connection();
        watchdog('UCLA Migration', "begin 2 @results", array('@results' => $connection), WATCHDOG_NOTICE);
        $repo = $connection->repository;
        watchdog('UCLA Migration', "begin 3 @results", array('@results' => $repo), WATCHDOG_NOTICE);
    // SPARQL query to get all objects in a given namespace.
        $query = "
        SELECT ?obj ?label
        FROM <#ri>
        WHERE {
          ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
     ?obj <fedora-model:label> ?label .
          FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:'))
        }
      ";

        watchdog('UCLA Migration', "begin 4 @results", array('@results' => $query), WATCHDOG_NOTICE);
        // Execute the query.
        $results = $repo->ri->sparqlQuery($query);

        watchdog('UCLA Migration', "begin 5 @results", array('@results' => var_dump($results)), WATCHDOG_NOTICE);

        foreach ($manifest_file as $file_path) {

            $file_path = trim($file_path);

            if (_is_valid_extension($file_path)) {
                watchdog('Reading manifest file', ' object @$file_path', array('@file_path' => $file_path), WATCHDOG_NOTICE);
                $file_path = _url_encode_http_address($file_path);

                if (fopen($file_path, "r")) {

                    $file_nameRaw = basename($file_path);
                    $file_name = strtolower($file_nameRaw);
                    $file_name = str_replace(".xml", "", $file_name);
                    $file_name = str_replace(".tif", "", $file_name);
                    $file_name = str_replace(".pdf", "", $file_name);
                    $file_name = str_replace("_tei", "", $file_name);
                    $file_name = str_replace("_mods", "", $file_name);
                    $file_name = str_replace(".mp4", "", $file_name);
                    $file_name = str_replace(".png", "", $file_name);
                    $file_name = str_replace(".jpg", "", $file_name);
    //                $file_name = str_replace("_a", "", $file_name);
                    watchdog('Ingest Success filename', ' object @file_name', array('@file_name' => $file_name), WATCHDOG_NOTICE);

                    foreach ($results as $result) {
                        $label = $result['label']['value'];
                        $label = strtolower($label);
                        // $label = urldecode($label);
                        $label = str_replace(".tif", "", $label);
                        $label = str_replace(".pdf", "", $label);

                        $label = str_replace(".xml", "", $label);
                        $label = str_replace("_mods", "", $label);

                        $label = str_replace("_tei", "", $label);
                        $label = str_replace(".mp4", "", $label);
                        $label = str_replace(".png", "", $label);
                        $label = str_replace(".jpg", "", $label);
    //                    $label = str_replace("_a", "", $label);

                        if ($file_name == $label) {

                            watchdog('Ingest Success started', ' object @file_name', array('@file_name' => $file_nameRaw), WATCHDOG_NOTICE);
                            $object = islandora_object_load($result['obj']['value']);
                            // $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:sp_large_image_cmodel');
                            _add_datastream_to_object($object, $file_path, $digitalObject);
                            break;
                        }
                    }
                    watchdog('Ingest Success', 'Migrated object @file_name', array('@file_name' => $file_name), WATCHDOG_NOTICE);
                } else {
                    watchdog('Ingest Error', 'Datastream ingest failed for @file_path ', array('@file_path' => $file_path), WATCHDOG_ERROR);
                    file_put_contents('DataStreamIngestFailed'.date("Y-m-d").'.txt',$file_path, FILE_APPEND);
                }
            }
        }
        $time_end = microtime(true);
        $time = $time_end - $time_start;
        watchdog('Ingest Time', 'Took @timecomplete seconds to finish the script', array('@timecomplete' => $time), WATCHDOG_NOTICE);
    }

    /**
     * Determines datastream format based on Mime type and calls the appropriate
     * function to attach the content
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $file_path
     *   Valid path to a file to be added as a datastream.
     */
    function _add_datastream_mp4_and_mods_to_object($object, $file_path, $modsFlag) {

        $ext = strtolower(pathinfo($file_path, PATHINFO_EXTENSION));
        if ($modsFlag === TRUE) {
            $ext = 'mp4';
            $file_path = str_replace('/metadata/', '/video/', $file_path);
            $file_path = str_replace('.xml', '', $file_path);
        }

        if ($ext === 'mp4') {
            _add_mp4_to_object($object, $file_path);
        }
        if ($ext === 'xml') {
            _add_modsxml_to_object($object, $file_path);
        }

        return $object;
    }

    /**
     * Determines datastream format based on Mime type and calls the appropriate
     * function to attach the content
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $file_path
     *   Valid path to a file to be added as a datastream.
     */
    function _add_datastream_images_and_mods_to_object($object, $file_path, $modsFlag) {

        //$ext = strtolower(pathinfo($file_path, PATHINFO_EXTENSION));
        if ($modsFlag === FALSE) {

            $file_path = str_replace('/mods/', '/Photos/', $file_path);
            $file_pathTif = str_replace('.xml', '.tif', $file_path);
            $file_pathJpeg = str_replace('.xml', '.jpg', $file_path);
            _add_images_to_object($object, $file_pathTif, $file_pathJpeg);
        } else {
            _add_modsxml_to_object($object, $file_path);
        }




        return $object;
    }

    /**
     * Determines datastream format based on Mime type and calls the appropriate
     * function to attach the content
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $file_path
     *   Valid path to a file to be added as a datastream.
     */
    function _add_datastream_to_object($object, $file_path, $digitalObject) {

        //$ext = strtolower(pathinfo($file_path, PATHINFO_EXTENSION));

        if ($digitalObject === 'TIFF') {
            _add_tiff_to_object($object, $file_path);
        }
        if ($digitalObject === 'TIF') {
            _add_tiff_to_object($object, $file_path);
        }
        if ($digitalObject === 'JPEG') {
            _add_jpeg_to_object($object, $file_path);
        }
        if ($digitalObject === 'JPG') {
            _add_jpeg_to_object($object, $file_path);
        }
        if ($digitalObject === 'TN') {
            _add_png_to_object($object, $file_path);
        }
        if ($digitalObject === 'PDF') {
            _add_pdf_to_object($object, $file_path);
        }
        if ($digitalObject === 'VIDEO') {
            _add_mp4_to_object($object, $file_path);
        }
        if ($digitalObject === 'MODS') {
            _add_modsxml_to_object($object, $file_path);
        }
        if ($digitalObject === 'TEI') {
            _add_teixml_to_object($object, $file_path);
        }

        return $object;
    }

    /**
     * Based on the extension of a file, determine if this is a valid file to be
     * ingested
     *
     * @param string $file_path
     *   Path to a file to test extension
     */
    function _is_valid_extension($file_path) {

        $ext = strtolower(pathinfo($file_path, PATHINFO_EXTENSION));

        if ($ext === 'tif') {
            return TRUE;
        }

        if ($ext === 'tiff') {
            return TRUE;
        }

        if ($ext === 'jpg') {
            return TRUE;
        }

        if ($ext === 'pdf') {
            return TRUE;
        }

        if ($ext === 'xml') {
            return TRUE;
        }

        if ($ext === 'png') {
            return TRUE;
        }

        if ($ext === 'mp4') {
            return TRUE;
        }

        return FALSE;
    }

    /**
     * Adds a tiff to the supplied object as the OBJ datastream.
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $tiff_path
     *   Valid path to a tiff file.
     */
    function _add_images_to_object($object, $tiff_path, $jpeg_path) {

        if (fopen($tiff_path, 'r')) {
            $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:sp_large_image_cmodel');
            $datastream = $object->constructDatastream('OBJ', 'M');
            watchdog('Ingest Success', 'The file is tif @file_name', array('@file_name' => $tiff_path), WATCHDOG_NOTICE);
            $datastream->label = "High Quality Tiff";
            $datastream->mimetype = "image/tiff";
            $datastream->setContentFromFile($tiff_path);
            $object->ingestDatastream($datastream);
        } else {
            if (fopen($jpeg_path, 'r')) {
                $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:sp_large_image_cmodel');
                $datastream = $object->constructDatastream('OBJ', 'M');
                watchdog('Ingest Success', 'The file is jpeg @file_name', array('@file_name' => $jpeg_path), WATCHDOG_NOTICE);
                $datastream->label = "High Quality JPEG";
                $datastream->mimetype = "image/jpeg";
                $datastream->setContentFromFile($jpeg_path);
                $object->ingestDatastream($datastream);
            }
        }
    }


    /**
     * Adds a png to the supplied object as the OBJ datastream.
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $png_path
     *   Valid path to a png file.
     */
    function _add_png_to_object($object, $png_path) {
        $datastream_id = 'TN';

        $ingest = !isset($object[$datastream_id]);

        if ($ingest) {
            $ds = $object->constructDatastream($datastream_id, "M");
            $ds->label = $datastream_id;
        }
        else {
            $ds = $object[$datastream_id];
        }
        $ds->mimetype = "image/png";
        $ds->content = file_get_contents($png_path);
        //->setContentFromFile($png_path); gave filesize() stats error
        if ($ingest) {
            $object->ingestDatastream($ds);
        }


    }

    /**
     * Adds a tiff to the supplied object as the OBJ datastream.
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $tiff_path
     *   Valid path to a tiff file.
     */
    function _add_tiff_to_object($object, $tiff_path) {
        $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:sp_large_image_cmodel');
        $datastream = $object->constructDatastream('OBJ', 'M');
        $datastream->label = "High Quality Tiff";
        $datastream->mimetype = "image/tiff";
        $datastream->setContentFromFile($tiff_path);
        $object->ingestDatastream($datastream);
    }

    /**
     * Adds a tiff to the supplied object as the OBJ datastream.
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $tiff_path
     *   Valid path to a tiff file.
     */
    function _add_jpeg_to_object($object, $jpeg_path) {
        $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:sp_basic_image');
        $datastream = $object->constructDatastream('OBJ', 'M');
        $datastream->label = "High Quality JPEG";
        $datastream->mimetype = "image/jpeg";
        $datastream->setContentFromFile($jpeg_path);
        $object->ingestDatastream($datastream);
    }

    /**
     * Adds a video to the supplied object as the OBJ datastream.
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $video_path
     *   Valid path to a video file.
     */
    function _add_mp4_to_object($object, $video_path) {
        $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:sp_videoCModel');
        $datastreamOBJ = $object->constructDatastream('OBJ', 'M');
        $datastreamOBJ->label = "High Quality Video";
        $datastreamOBJ->mimetype = "video/mp4";
        $datastreamOBJ->setContentFromFile($video_path);
        $object->ingestDatastream($datastreamOBJ);
        $datastreamMP4 = $object->constructDatastream('MP4', 'M');
        $datastreamMP4->label = "jwPlayer Video";
        $datastreamMP4->mimetype = "video/mp4";
        $datastreamMP4->setContentFromFile($video_path);
        $object->ingestDatastream($datastreamMP4);
    }

    /**
     * Adds/Updates a PDF to the supplied object as the OBJ datastream.
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $pdf_path
     *   Valid path to a pdf file.
     */
    function _add_pdf_to_object($object, $pdf_path) {

        // get pdf datastream from object if exist or else create a new one add this logic
        watchdog('Ingest Success', 'In add/update pdf @file_name', array('@file_name' => $pdf_path), WATCHDOG_NOTICE);
        $is_new_pdf_ds = FALSE;
        if (isset($object['OBJ'])) {
            $datastream = $object['OBJ'];
        }
        else {
            $relation_exists = FALSE;
            foreach ($object->relationships->get(FEDORA_MODEL_URI, 'hasModel') as $relationship) {
                 if($relationship['object']['value'] == 'islandora:sp_pdf'){
                     $relation_exists =TRUE;
                     break;
                 }
            }
            if(!$relation_exists) {
                $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:sp_pdf');
            }
            $datastream = $object->constructDatastream('OBJ', 'M');
            $datastream->label = "PDF Document";
            $datastream->mimetype = "application/pdf";
            $is_new_pdf_ds = TRUE;
        }

        try {
            $datastream->setContentFromFile($pdf_path);
            if ($is_new_pdf_ds) {
                $object->ingestDatastream($datastream);
            }
        }
        catch (Exception $e) {
            watchdog('Ingest Fail', 'Failed to update @label (@object)',
                array(
                    '@object' => $object->id,
                    '@label' => $object->label,
                ),
                WATCHDOG_NOTICE
            );
        }

        watchdog('Ingest Success', 'Migrated object @file_name', array('@file_name' => $pdf_file), WATCHDOG_NOTICE);
    }

    /**
     *
     * Adds a MODS xml to the supplied object as the OBJ datastream.
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $tei_path
     *   Valid path to a mods xml file.
     */
    function _add_teixml_to_object($object, $tei_path) {
        // get mods datastream from object if exist or else create a new one add this logic
        watchdog('Ingest Success', 'In add teixml @file_name', array('@file_name' => $tei_path), WATCHDOG_NOTICE);
        $object->relationships->add(FEDORA_MODEL_URI, 'hasModel', 'islandora:manuscriptCModel');
        $is_new_tei_ds = FALSE;
        if (isset($object['TEI'])) {
            $datastream = $object['TEI'];
        } else {
            $datastream = $object->constructDatastream('TEI', 'M');
            $datastream->label = "TEI Record";
            $datastream->mimetype = "text/xml";
            $is_new_tei_ds = TRUE;
        }
        watchdog('Ingest Success', 'Found datastream @file_name', array('@file_name' => $tei_path), WATCHDOG_NOTICE);
        try {
            $datastream->setContentFromFile($tei_path);
            if ($is_new_tei_ds) {
                $object->ingestDatastream($datastream);
            }
        }
        catch (Exception $e) {
            watchdog('Ingest Fail', 'Failed to update @label (@object)',
                array(
                    '@object' => $object->id,
                    '@label' => $object->label,
                ),
                WATCHDOG_NOTICE
            );
        }

        watchdog('Ingest Success', 'Migrated object @file_name', array('@file_name' => $tei_file), WATCHDOG_NOTICE);
    }

    /**
     * Adds a MODS xml to the supplied object as the OBJ datastream.
     *
     * @param FedoraObject $object
     *   The object you wish to add the datastream to.
     *
     * @param string $mods_path
     *   Valid path to a mods xml file.
     */
    function _add_modsxml_to_object($object, $mods_path) {
        // get mods datastream from object if exist or else create a new one add this logic
        watchdog('Ingest Success', 'In add modsxml @file_name', array('@file_name' => $mods_path), WATCHDOG_NOTICE);
        $is_new_mods_ds = FALSE;
        if (isset($object['MODS'])) {
            $datastream = $object['MODS'];
        }
        else {
            $datastream = $object->constructDatastream('MODS', 'M');
            $datastream->label = "MODS Record";
            $datastream->mimetype = "text/xml";
            $is_new_mods_ds = TRUE;
        }

        try {
            $mods_file = file_get_contents($mods_path);
            $datastream->content = $mods_file;
            if ($is_new_mods_ds) {
                $object->ingestDatastream($datastream);
            }
        }
        catch (Exception $e) {
            watchdog('Ingest Fail', 'Failed to update @label (@object)',
                array(
                    '@object' => $object->id,
                    '@label' => $object->label,
                ),
                WATCHDOG_NOTICE
            );
        }

        watchdog('Ingest Success', 'Migrated object @file_name', array('@file_name' => $mods_file), WATCHDOG_NOTICE);
    }

    /**
     * Given a list of pids, purges the object from Fedora
     *
     * @param $list_of_pids
     *   A list of pids for objects to be removed
     *
     */
    function _purge_object_by_pid($pids) {
        watchdog('In Purged function', WATCHDOG_NOTICE);
        foreach ($pids as $pid) {
            watchdog('Object to be purged', 'pid @file_name', array('@file_name' => $pid), WATCHDOG_NOTICE);
            $fedora_obj = islandora_object_load(trim($pid));
            watchdog('Object to be purged', 'object @file_name', array('@file_name' => var_dump($fedora_obj)), WATCHDOG_NOTICE);
            if ($fedora_obj) {
                if (islandora_delete_object($fedora_obj)) {
                    drush_log("Successfully purged pid {$pid} ", 'ok');
                } else {
                    drush_log("Failure to purge pid {$pid} ", 'ok');
                }
            }
        }
        watchdog('out Purged function', WATCHDOG_NOTICE);
    }

    /**
     * Given a Fedora namespace, return a title/label to pid mapping
     * the given title and namespace in the triplestore
     *
     * @param string $fedora_namespace
     *  The fedora namespace to search for the given title
     *
     */
    function _create_pid_title_map_by_namespace($fedora_namespace) {

        $connection = islandora_get_tuque_connection();
        $repo = $connection->repository;
        $query = "
            SELECT ?identifier ?label
            FROM <#ri>
            WHERE {
              ?obj <info:fedora/fedora-system:def/model#hasModel> ?model .
              FILTER(regex(str(?obj), '^info:fedora/$fedora_namespace:')) .
              ?obj <fedora-model:label> ?label .
              ?obj <dc:identifier> ?identifier .
              }
            ORDER BY ?identifier";

        $results = $repo->ri->sparqlQuery($query);

        $title_to_pid = array();

        foreach ($results as $result) {
            $title_to_pid[$result['label']['value']] = $result['identifier']['value'];
        }

        return $title_to_pid;
    }

    function _url_encode_http_address($address_to_encode) {

        $url_parsed = parse_url($address_to_encode);
        $path_to_encode = $url_parsed['path'];
        $sections_to_encode = explode('/', $path_to_encode);

        for ($i = 0; $i < sizeof($sections_to_encode); $i++) {
            $sections_to_encode[$i] = rawurlencode($sections_to_encode[$i]);
        }

        $encoded_path = implode('/', $sections_to_encode);
        $full_url = $url_parsed['scheme'] . '://' . $url_parsed['host'] . $encoded_path;

        return $full_url;
    }

    function add_items_to_collection() {

        $fedora_dest_collection = drush_get_option('fedora_dest_collection');
        $manifest_file_path = drush_get_option('manifest_file_path');

        $manifest_file = file($manifest_file_path, FILE_IGNORE_NEW_LINES);
        if (!$manifest_file) {
            drush_set_error('File not found', "Could not locate manifest file file $manifest_file_path", "Error: ");
            return;
        }

        if (!isset($fedora_dest_collection)) {
            drush_set_error('Fedora namespace not provided', 'A Fedora namespace to associate with the ingest must be provided', 'Error: ');
            return;
        }

        module_load_include('inc', 'islandora_basic_collection', 'includes/utilities');
        $new_collection = islandora_object_load($fedora_dest_collection . ':1');


        foreach ($manifest_file as $object_pid) {
            $fedora_pid = trim($object_pid);
            $object = islandora_object_load($fedora_pid);
            print($object);
            if ($object && $new_collection) {
                print("adding");
                islandora_basic_collection_add_to_collection($object, $new_collection);
            }
            print("loaded pid" . $fedora_pid);
        }
    }
